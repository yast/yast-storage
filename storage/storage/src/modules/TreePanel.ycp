/**
 * File:        TabPanel.ycp
 * Package:     yast2-storage
 * Summary:	Expert Partitioner
 * Authors:     Arvin Schnell <aschnell@suse.de>
 *
 * The Tree widget must have id `tree.  The ids of the items of the Tree
 * widget must be made of symbols or strings.
 */
{
    module "TreePanel";
    

    import "Event";


    map<any, map> data = nil;

    any current_item = nil;


    global const term empty_panel = `VBox(`VStretch(), `HStretch());


    void CallCreate()
    {
	map tmp = data[current_item]:nil;
	void(any) create_func = (void(any)) tmp[`create]:nil;
	if (create_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    create_func(user_data);
	}
    }

    void CallRefresh()
    {
	map tmp = data[current_item]:nil;
	void(any) refresh_func = (void(any)) tmp[`refresh]:nil;
	if (refresh_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    refresh_func(user_data);
	}
    }

    void CallHandle(map event)
    {
	map tmp = data[current_item]:nil;
	void(any, map) handle_func = (void(any, map)) tmp[`handle]:nil;
	if (handle_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    handle_func(user_data, event);
	}
    }

    void CallDestroy()
    {
	map tmp = data[current_item]:nil;
	void(any) destroy_func = (void(any)) tmp[`destroy]:nil;
	if (destroy_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    destroy_func(user_data);
	}
    }


    /**
     * Initialises internal data and calls the create function of the
     * selected panel.
     *
     * When calling this function the Tree widget must already exist.
     */
    global void Init(map<any, map> d)
    {
	data = d;

	current_item = UI::QueryWidget(`tree, `CurrentItem);
	CallCreate();
    }

    /**
     * Update the contents of the Tree widget.
     */
    global void Update(map<any, map> d, list<term> tree, any new_item)
    {
	any old_item = current_item;

	UI::ChangeWidget(`tree, `Items, tree);

	if (new_item == nil)
	    UI::ChangeWidget(`tree, `CurrentItem, current_item);
	else
	    UI::ChangeWidget(`tree, `CurrentItem, new_item);

	new_item = UI::QueryWidget(`tree, `CurrentItem);

	if (old_item != new_item)
	{
	    CallDestroy();
	    data = d;
	    current_item = new_item;
	    CallCreate();
	}
	else
	{
	    data = d;
	}
    }

    global void Create()
    {
	CallCreate();
    }

    global void Refresh()
    {
	CallRefresh();
    }

    /**
     * Handle user input by either switching the panel or delegating the input
     * to the selected panel.
     */
    global void Handle(map event)
    {
	symbol widget = Event::IsWidgetActivatedOrSelectionChanged(event);

	if (widget == `tree)
	{
	    any new_current_item = UI::QueryWidget(`tree, `CurrentItem);
	    if (new_current_item != current_item)
	    {
		CallDestroy();
		current_item = new_current_item;
		CallCreate();
	    }
	}
	else
	{
	    CallHandle(event);
	}
    }

    /*
     * Set new active item of the tree ( + replace main dlg content accordingly)
     */
    global void SwitchToNew( any new_current_item )
    {
	if (current_item != new_current_item)
	{
	    UI::ChangeWidget(`tree, `CurrentItem, new_current_item);
	    CallDestroy();
	    current_item = new_current_item;
	    CallCreate();
	}
    }

    /**
     * Delegating destroying to the selected panel.
     */
    global void Destroy()
    {
	CallDestroy();
    }
}
