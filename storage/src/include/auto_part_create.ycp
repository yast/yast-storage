/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * Module:		auto_part_create.ycp
 *
 * Authors:		Andreas Schwab (schwab@suse.de)
 *			Klaus KÃ¤mpf (kkaempf@suse.de)
 *
 * Purpose:		This module creates the neccessary partitions
 *			in the targetMap
 *
 * $Id$
 *
 * used globals
 *
 * defined functions
 */
{
    textdomain "storage";

    import "Storage";
    import "Partitions";
    import "StorageProposal";

boolean create_partitions( map<string,map> tgmap, map disk, list<map> partitions )
    {
    y2milestone( "create_partitions disk:%1",
                 haskey(disk,"partitions")?remove(disk,"partitions"):disk );
    y2milestone( "create_partitions partitions %1", partitions );
    StorageProposal::flex_init_swapable( tgmap );
    boolean ret = false;
    boolean has_flex = StorageProposal::has_flex_proposal();
    string vm = StorageProposal::GetProposalVM();
    y2milestone( "create_partitions flex %1 vm %2", has_flex, vm );
    disk["partitions"] = partitions;
    if( StorageProposal::NeedNewDisklabel(disk) )
	{
	tgmap[disk["device"]:"","disklabel"] = "gpt";
	tgmap[disk["device"]:"","del_ptable"] = true;
	}
    map keep = find( map p, partitions, 
		     ``(!p["delete"]:false&&p["type"]:`unknown!=`free));
    if( size(vm)==0 )
	{
	if( has_flex )
	    {
	    map flex = StorageProposal::do_flexible_disk( disk );
	    if( flex["ok"]:false )
		partitions = flex["disk","partitions"]:[];
	    }
	else
	    {
	    integer num_del_exist = size(filter(map p, partitions,
						``(p["type"]:`unknown!=`free&&
						   p["delete"]:false)));
	    integer num_del_free = size(filter(map p, partitions,
						``(p["type"]:`unknown==`free&&
						   p["delete"]:false)));
	    map r = StorageProposal::can_swap_reuse( disk["device"]:"", partitions, tgmap );
	    if( haskey( r, "partitions" ))
		partitions = r["partitions"]:[];
	    else if( haskey( r, "targets" ))
		tgmap = r["targets"]:$[];

	    y2milestone( "create_partitions num_del_exist %1 num_del_free %2 swap_reuse %3", 
			 num_del_exist, num_del_free, size(r)>0 );
	    y2milestone( "create_partitions keep %1", keep );
	    if( keep!=nil && size(r)>0 && 
	        !StorageProposal::GetProposalHome() && 
		!StorageProposal::GetProposalBtrfs() &&
	        num_del_exist==1 && num_del_free==0 )
		{
		y2milestone( "create_partitions single special" );
		boolean first = true;
		partitions = maplist( map p, partitions, 
				      ``{
				      if( p["delete"]:false && first )
					  {
					  p = remove( p, "delete" );
					  first = false;
					  p = Storage::SetVolOptions( p, "/", 
					                              Partitions::DefaultFs(), 
								      "", "", "" );
					  y2milestone( "create_partitions single p %1", p );
					  }
				      return( p );
				      });
		}
	    else
		{
		boolean have_swap =  size(r)>0 && !StorageProposal::GetProposalSuspend();
		partitions = StorageProposal::get_proposal( have_swap, disk );
		}
	    }
	y2milestone( "create_partitions %1", partitions );
	}
    else
	{
	map id_save = $[];
	disk["partitions"] = maplist( map p, disk["partitions"]:[],
	    ``{
	    if( !p["delete"]:false && 
	        p["type"]:`unknown!=`free && p["type"]:`unknown!=`extended )
		{
		id_save[p["device"]:""] = p["fsid"]:0;
		p["fsid"] = Partitions::fsid_hibernation;
		}
	    return( p );
	    });
	y2milestone( "create_partitions id_save %1", id_save );
	y2milestone( "create_partitions ps %1", disk["partitions"]:[] );
	map r = StorageProposal::get_proposal_vm( tgmap, vm, disk );
	ret = r["ok"]:false;
	if( ret )
	    {
	    string ddev = disk["device"]:"";
	    tgmap = r["target"]:$[];
	    tgmap[ddev,"partitions"] = maplist( map p, tgmap[ddev,"partitions"]:[],
		``{
		if( haskey( id_save, p["device"]:"" ))
		    p["fsid"] = id_save[p["device"]:""]:0;
		return( p );
		});
	    y2milestone( "create_partitions ps %1", tgmap[ddev,"partitions"]:[] );
	    }
	}
    keep = find( map p, partitions, 
		 ``(!p["delete"]:false&&!p["create"]:false));
    partitions = filter( map p, partitions, ``(p["type"]:`unknown!=`free));
    y2milestone( "create_partitions keep %1", keep );
    if( size(vm)==0 )
	{
	ret = size(partitions)>0;
	if( ret )
	    {
	    tgmap[disk["device"]:"","partitions"] = partitions;
	    tgmap = Storage::SpecialBootHandling(tgmap);
	    }
	}
    if( ret )
	{
	Storage::SetTargetMap( tgmap );
	Storage::AddMountPointsForWin(tgmap);
	}
    y2milestone( "create_partitions ret %1", ret );
    return( ret );
    }; // create_partitions

}
