/**
 * File:	ep-lib.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";


    list<string> AddedToList(list<string> old, list<string> new)
    {
	return filter(string tmp, new, { return !contains(old, tmp); });
    }


    list<string> RemovedFromList(list<string> old, list<string> new)
    {
	return filter(string tmp, old, { return !contains(new, tmp); });
    }


    string ParentDevice(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	map disk = target_map[device]:nil;
	map part = nil;

	if (disk == nil)
	{
	    foreach(string s, map d, target_map, {
		part = find(map p, d["partitions"]:[], { return p["device"]:"" == device; });
		if (part != nil) {
		    disk = d;
		    break;
		}
	    });
	}

	return disk["device"]:"";
    }


    boolean EpDeleteDevice(string id)
    {
	map<string,map> tg =  Storage::GetTargetMap();

	map<string,any> part = $[];
	map<string,any> disk = Storage::GetDisk( tg, id );

	if( !haskey( tg, id ) )
	    part = Storage::GetPartition( tg, id );
	y2milestone( "id:%1 part:%2", id, part );
	if( !haskey( tg, id ) && size(part)==0 )
	{
	    return false;
	}

	if( disk["readonly"]:false )
	{
	    Popup::Error( Partitions::RdonlyText( disk["device"]:"", true ));
	    return false;
	}

	if( haskey( tg, id ) )
	{
	    if( tg[id,"type"]:`CT_UNKNOWN == `CT_MD )
	    {
		return false;
	    }
	    else if( tg[id,"type"]:`CT_UNKNOWN == `CT_LVM )
	    {
		string current_vg = substring( tg[id,"device"]:"", 5 );
		HandleRemoveVg( tg, current_vg );
	    }
	    else if( tg[id,"type"]:`CT_UNKNOWN == `CT_DMRAID )
	    {
		if( Popup::YesNo( sformat(_("Really delete BIOS RAID %1?"), id )))
		{
		    if( deleteAllDevPartitions( disk, Stage::initial(), false ))
			Storage::DeleteDmraid( id );
		    return true;
		}
	    }
	    // YesNo popup text %1 is replaced by a disk name e.g. /dev/hda
	    else if( Popup::YesNo( sformat(_("Really delete all partitions on %1?"), id )))
	    {
		deleteAllDevPartitions( disk, Stage::initial(), false );
		return true;
	    }
	}
	else if( part["type"]:`unknown==`lvm )
	{
	    if( !check_device_delete( part, false, Stage::initial(), $[] ))
	    {
		return false;
	    }
	    else
	    {
		HandleRemoveLv( tg, id );
		return true;
	    }
	}
	else
	{
	    /////////////////////////////////////////////////////
	    // delete algorithm:
	    // if you find newly created (but until now not realy
	    // written) partition (sign: "create = true"): delete it
	    // else there must be already existing partition: mark it
	    // with "delete = true"

	    y2milestone( "delete part %1", part );
	    /////////////////////////////////////////////////////
	    // check if the partition can be deleted

	    if( part["type"]:`primary == `extended &&
		!check_extended_delete( disk, Stage::initial() ))
	    {
		return false;
	    }
	    if( part["type"]:`primary != `extended &&
		!check_device_delete( part, false, Stage::initial(),
				      disk ))
	    {
		return false;
	    }

	    /////////////////////////////////////////////////////
	    // now delete partition!!

	    // YesNo popup text, %1 is replaced by a device name e.g. /dev/hda1
	    if( Popup::YesNo( sformat(_("Really delete %1?"),
				      part["device"]:"" )))
	    {
		if( (search( id, "/dev/loop")==0 ||
		     search( id, "/dev/mapper/")==0) &&
		    size(part["fpath"]:"")>0 &&
		    Mode::normal() &&
		    // YesNo popup.  %1 is path to a file
		    Popup::YesNo( sformat(_("\nShould the loop file %1 also be removed?
"), part["fpath"]:"" )))
		{
		    Storage::DeleteLoop( disk["device"]:"",
					 part["fpath"]:"", true );
		}
		if( part["type"]:`unknown == `nfs )
		{
		    Storage::DeleteDevice( "/dev/nfs",
					   part["device"]:"" );
		}
		else
		{
		    Storage::DeleteDevice( disk["device"]:"",
					   part["device"]:"" );
		}
		return true;
	    }
	}

	return false;
    }


    void ImportMountPoints()
    {
	map<string,map> od = (map<string,map>)Storage::GetOndiskTarget();
	list<list> fstab = scanAndReadExistingFstab( od );
	y2milestone( "adapt_mp fstab %1", fstab );
	list ti = maplist( list e, fstab, ``(AddFstabToData( od, (list<map>)e)[1]:$[]));
	y2milestone( "adapt_mp ti %1", ti );

	integer idx = FstabAddDialog( ti );
	if( idx>=0 )
	{
	    od = (map<string,map>)Storage::GetOndiskTarget();
	    y2milestone( "adapt_mp use fstab idx %1", idx );
	    ti = AddFstabToData( od, (list<map>)fstab[idx]:[] );
	    Storage::ResetOndiskTarget();
	    boolean import_ok = true;
	    foreach( string d, map disk, ti[0]:$[],
		     ``{
			 foreach( map p, disk["partitions"]:[],
				  ``{
				      string key = (p["type"]:`unknown != `loop) ? (p["device"]:"error") : (p["fpath"]:"error");
				      if( size(p["mount"]:"")>0 && p["enc_type"]:`none!=`none &&
					  !p["tmpcrypt"]:false && Storage::NeedCryptPwd(key) )
				      {
					  boolean ok = false;
					  string dev = p["device"]:"";
					  string pwd = "";
					  do
					      {
					      ok = false;
					      pwd = DlgCreateCryptFs( dev, 1, false, false );
					      if( pwd != nil && size(pwd)>0 )
						  {
						  if( Storage::CheckCryptOk( dev, pwd ) )
						      {
						      ok = Storage::SetCryptPwd( dev, pwd ) &&
							   Storage::SetCrypt( dev, true, false );
						      }
						  }
					      else if( size(pwd)==0 )
						  {
						  ok = true;
						  import_ok = false;
						  }
					      }
					  while( !ok );
				      }
				  });
		     });
	    if( import_ok )
		Storage::SetTargetMap(ti[0]:$[]);
	}
    }
}
