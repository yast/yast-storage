/**
 * File:	ep-dialogs.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    include "partitioning/custom_part_lib.ycp";

    textdomain "storage";

    string MiniWorkflowStepFormatMountHelptext()
    {
	// helptext
	string helptext = _("<p>First, choose whether the partition should be
formatted and the desired file system type.</p>");

	// helptext
	helptext = helptext + _("<p>Changing the encryption on an existing
volume will delete all data on it.</p>");

	// helptext
	helptext = helptext + _("<p>Then, choose whether the partition should
be mounted and enter the mount point (/, /boot, /usr, /var, etc.).</p>");

	return helptext;
    }


    symbol MiniWorkflowStepFormatMount(map<string, any> &orig_data)
    {
	map<string, any> data = orig_data;
	y2milestone("MiniWorkflowStepFormatMount data:%1", data);

        //retrieve all filesystems
	map<symbol, map<symbol, any> > all_filesystems = FileSystems::GetAllFileSystems(true, true);

	list <string> ProposeMountpoints( symbol used_fs, string current_mp )
	{
	    map <symbol, any> fs_data = all_filesystems[used_fs]: $[];

	   //not much choice for swap partitions :)
	   if( used_fs == `swap )
	   {
		return fs_data[ `mountpoints ]:[];
	   }
	   //otherwise, ask notUsedMountPoint, it will filter out
	   //mountpoint already in use + add current mountpoint
	   else
	   {
		list <string> not_used = notUsedMountpoints( Storage::GetTargetMap(), fs_data[ `mountpoints]:[]);
		return ( list <string> ) union( [current_mp], not_used );
	   }
	}


	boolean do_format = data["format"]:false;
	symbol used_fs = data["used_fs"]:`unknown;
	symbol default_crypt_fs = data["type"]:`unknown == `loop ? `luks : `none;
	boolean crypt_fs = data["enc_type"]:default_crypt_fs != `none;
	string mount = data["mount"]:"";
	boolean do_mount = mount != "";


	// returns true also when password can be omitted (e.g. encrypted swap)
	boolean NeedPassword()
	{
	    return crypt_fs;
	}


	boolean AskPassword()
	{
	    boolean ret = NeedPassword();
	    if( ret && !do_format && size(data["mount"]:"")>0 )
		{
		string key = (data["type"]:`unknown != `loop) ? (data["device"]:"error") : (data["fpath"]:"error");
		ret = Storage::NeedCryptPwd(key);
		}
	    return ret;
	}


	/* MiniWorkflowStepPartitionSize data:
		$["create":true,
		  "cyl_size":8225280,
		   "device":"/dev/sda1",
		   "disk_device":"/dev/sda",
		   "new":true,
		   "slots":$[`primary:[1, 65]],
		   "type":`primary]
	*/

	//Supply some reasonable defaults for newly created partitions
	//and mark it for formatting, too
	if (data["new"]:false && !data["formatmount_proposed"]:false)
	{
	    data["formatmount_proposed"] = true;

	    //propose new mountpoint and filesystem
	    string mount_point_proposal = SingleMountPointProposal( );
	    used_fs = Partitions::DefaultFs();

	    //special case for boot partition
	    if (mount_point_proposal == Partitions::BootMount())
		used_fs = Partitions::DefaultBootFs();

	    data["format"] = true;
	    data["fsid"] = Partitions::fsid_native;
	    data["ori_fsid"] = Partitions::fsid_native;
	    data["used_fs"] = used_fs;

	    //set globals
	    do_format = true;
	    mount = mount_point_proposal;
	    do_mount = mount != "";

	    if (data["type"]:`unknown == `loop)
		do_mount = true;
	}


	term tmp1 = `Empty();
	if (contains([`primary, `extended, `logical], data["type"]:`none))
	{
	    tmp1 = `VBox(`id(`do_not_format_attachment),
			 FsidComboBox(data, FileSystems::GetAllFileSystems(true, true))
		    );
	}

	list mountpoints = ProposeMountpoints( used_fs, mount );

	term contents = `HVSquash(`VStackFrames(
				      `FrameWithMarginBox(_("Formatting Options"),
					     `RadioButtonGroup(`id(`format),
							       `VBox(
								   `LeftRadioButtonWithAttachment(`id(`do_format), `opt(`notify),
												  _("Format partition"),
												  `VBox(`id(`do_format_attachment),
												      FileSystemsComboBox(data, all_filesystems)
												      )),
								   `VSpacing(0.45),
								   `LeftRadioButtonWithAttachment(`id(`do_not_format), `opt(`notify),
												  _("Do not format partition"),
												  tmp1),
								   `VSpacing(0.45),
								   CryptButton(data)
								   )
							)
					  ),
				      `FrameWithMarginBox(_("Mounting Options"),
					     `RadioButtonGroup(`id(`mount),
							       `VBox(
								   `LeftRadioButtonWithAttachment(`id(`do_mount), `opt(`notify),
												  _("Mount partition"),
												  `VBox(
												      `id(`do_mount_attachment),
												      `ComboBox(`id(`mount_point), `opt(`editable, `hstretch, `notify),
														_("Mount Point"), mountpoints),
												      `PushButton(`id(`fstab_options), `opt(`hstretch),
														  // button text
														  _("Fs&tab Options..."))
												      )),
								   `VSpacing(0.45),
								   `LeftRadioButton(`id(`do_not_mount), `opt(`notify),
										    _("Do not mount partition"))
								   )
						 )
					  )
				      )
	    );

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepFormatMountHelptext());

	MiniWorkflow::SetLastStep(!AskPassword());

	UI::ChangeWidget(`id(`format), `Value, do_format ? `do_format : `do_not_format);
	UI::ChangeWidget(`id(`do_format_attachment), `Enabled, do_format);
	UI::ChangeWidget(`id(`crypt_fs), `Value, crypt_fs);
	UI::ChangeWidget(`id(`do_not_format_attachment), `Enabled, !do_format);
	UI::ChangeWidget(`id(`mount), `Value, do_mount ? `do_mount : `do_not_mount);
	UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, do_mount);
	UI::ChangeWidget(`id(`mount_point), `Value, mount);

	symbol widget = nil;

	data = HandlePartWidgetChanges(true, widget, all_filesystems, orig_data, data);

	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    if (widget != `back && widget != `abort)
	    {
		data = HandlePartWidgetChanges(false, widget, all_filesystems, orig_data, data);
	    }

	    switch (widget)
	    {
		//user has chosen different filesystem
		case `fs:
		{
		    used_fs = (symbol) UI::QueryWidget(`id(`fs), `Value);

		    //retrieve info about fs user has selected
		    map used_fs_data = all_filesystems[used_fs]:$[];
		    y2milestone("Selected filesystem details %1", used_fs_data);

		    if (used_fs != data["used_fs"]:`none)
		    {
			//set file system type
			data["used_fs"] = used_fs;
			data = filter(string key, any value, data, { return key != "fs_options"; });

			//set file system ID (and update the File System ID widget
			//that is - FsidComboBox)
			data["fsid"] = used_fs_data[`fsid]: Partitions::fsid_native;
			UI::ChangeWidget( `id(`fsid_point), `Value, used_fs_data[`fsid_item]:"");

			//suggest some nice mountpoints if user wants to mount this partition
			if (do_mount)
			{
			    UI::ChangeWidget(`id(`mount_point), `Items, ProposeMountpoints( used_fs, mount ));
			}
		    }
		    break;
		}

		case `crypt_fs:
		    crypt_fs = (boolean) UI::QueryWidget(`id(`crypt_fs), `Value);
		    MiniWorkflow::SetLastStep(!AskPassword());
		    break;

		    /* already done in HandlePartWidgetChanges
		case `fs_options:
		    map fs_options = FileSystems::DefaultFormatOptions(data);
		    if (size(fs_options) > 0 && !haskey(data, "fs_options"))
			data["fs_options"] = FileSystems::DefaultFormatOptions(data);

		    map filesystems = FileSystems::GetAllFileSystems(true, true);
		    data["fs_options"] = FileSystemOptions(data["fs_options"]:$[], filesystems[data["used_fs"]:`unknown]:$[]);
		    break;
		    */

		    /* already done in HandlePartWidgetChanges
		case `fstab_options:
		    string fstopt = FileSystems::DefaultFstabOptions(data);
		    if (size(fstopt) > 0 && !haskey(data, "fstopt"))
			data["fstopt"] = fstopt;

		    data = FstabOptions(data, data);
		    break;
		    */

		case `do_format:
		    do_format = (boolean) UI::QueryWidget(`id(`do_format), `Value);
		    data["used_fs"] = (symbol) UI::QueryWidget(`id(`fs), `Value);

		    UI::ChangeWidget(`id(`do_format_attachment), `Enabled, true);
		    UI::ChangeWidget(`id(`do_not_format_attachment), `Enabled, false);
		    UI::SetFocus(`id(`fs));
		    MiniWorkflow::SetLastStep(!AskPassword());
		    break;

		case `do_not_format:
		    do_format = (boolean) UI::QueryWidget(`id(`do_format), `Value);
		    UI::ChangeWidget(`id(`do_format_attachment), `Enabled, false);
		    UI::ChangeWidget(`id(`do_not_format_attachment), `Enabled, true);
		    MiniWorkflow::SetLastStep(!AskPassword());
		    break;

		case `fsid_point:
		    // TODO
		    break;

		case `do_mount:
		    do_mount = true;
		    UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, true);
		    UI::SetFocus(`id(`mount_point));
		    //propose mountpoints
		    //UI::ChangeWidget(`id(`mount_point), `Items, ProposeMountpoints( used_fs, mount ));
		    break;

		case `do_not_mount:
		    do_mount = false;
		    UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, false);
		    break;

		case `next:
		    do_format = (boolean) UI::QueryWidget(`id(`do_format), `Value);
		    crypt_fs = (boolean) UI::QueryWidget(`id(`crypt_fs), `Value);
		    do_mount = (boolean) UI::QueryWidget(`id(`do_mount), `Value);
		    mount = (string) UI::QueryWidget(`id(`mount_point), `Value);

		    // TODO: checks
		    //crypt-file specific checks
		    if (data["type"]:`unknown == `loop)
		    {
			//is encrypt fs checked?
			if (!crypt_fs)
			{
			    // error popup
			    Popup::Error(_("Crypt files must be encrypted."));
			    UI::ChangeWidget(`id(`crypt_fs), `Value, true);
			    UI::SetFocus(`id(`crypt_fs));
			    widget = `again;
			    continue;
			}

			//enforce formatting the crypt-file
			if (data["create_file"]:false && !do_format)
			{
			    // error popup
			    Popup::Error(_("You chose to create the crypt file, but did not specify
that it should be formatted. This does not make sense.

Also check the format option.
"));
			    UI::ChangeWidget(`id(`do_format), `Value, true);
			    UI::ChangeWidget(`id(`do_format_attachment), `Enabled, true);
			    UI::SetFocus(`id(`fs));
			    widget = `again;
			    continue;
			}
			//enforce specifying mountpoint
			if (!do_mount)
			{
			    // error popup
			    Popup::Error(_("Crypt files require a mount point."));
			    UI::ChangeWidget(`id(`do_mount), `Value, true);
			    UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, true);
			    UI::SetFocus(`id(`mount_point));
			    widget = `again;
			    continue;
			}
		    }

		    if (do_mount)
		    {
			map ret_mp = CheckOkMount(data["device"]:"error", orig_data, data);
			if (!ret_mp["ok"]:false)
			{
			    if (ret_mp["field"]:`none != `none)
				UI::SetFocus(`id(ret_mp["field"]:`none));
			    widget = `again;
			    continue;
			}
		    }

		    if (do_format)
		    {
			if (!check_ok_fssize(data["size_k"]:0, data))
			{
			    widget = `again;
			    continue;
			}
		    }

		    break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    if (NeedPassword())
		data["enc_type"] = data["format"]:false ? `luks : `twofish;
	    else
		data["enc_type"] = `none;

	    data["format"] = do_format;
	    data["mount"] = do_mount ? mount : "";

	    if (!data["format"]:false)
		data = filter(string key, any value, data, { return key != "fs_options"; });

	    if (contains([`primary, `extended, `logical], data["type"]:`unknown))
		if (data["fsid"]:0 != orig_data["fsid"]:0)
		    data["change_fsid"] = true;

	    if (!AskPassword())
		widget = `finish;

	    orig_data = data;
	}

	y2milestone("MiniWorkflowStepFormatMount data:%1 ret:%2", data, widget);

	return widget;
    }


    string MiniWorkflowStepPasswordHelptext(map<string, any> data)
    {
	integer min_pw_len = data["format"]:false ? 8 : 1;
	boolean empty_pw_allowed = EmptyCryptPwdAllowed(data);

	// helptext
	string helptext = _("<p>
Keep in mind that this file system is only protected when it is not
mounted. Once it is mounted, it is as secure as every other
Linux file system.
</p>");

	if (empty_pw_allowed)
	{
	    if (data["used_fs"]:`unknown == `swap)
		// helptext
                helptext = helptext + _("<p>
The file system used for this volume is swap. You may leave the crypt password
empty but then the swap device cannot be used for hibernating (suspend to
disk).
</p>
");
	    else
		// helptext
		helptext = helptext + _("<p>
This mount point corresponds to a temporary filesystem like /tmp or /var/tmp.
You may leave the crypt password empty. If you do this, the system will create
a random password at system startup for you. This means, you will lose all
data on these filesystems at system shutdown.
</p>
");
	}

        // helptext
        helptext = helptext + _("<p>
If you forget your password, you will lose access to the data on your file system.
Choose your password carefully. A combination of letters and numbers
is recommended. To ensure the password was entered correctly,
enter it twice.
</p>
");

        // helptext, %1 is replaced by integer
        helptext = helptext + sformat(_("<p>
You must distinguish between uppercase and lowercase. A password should have at
least %1 characters and, as a rule, not contain any special characters
(e.g., letters with accents or umlauts).
</p>
"), min_pw_len);

	// helptext
	helptext = helptext + _("<p>
Do not forget this password!
</p>");

	return helptext;
    }


    symbol MiniWorkflowStepPassword(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepPassword data:%1", data);

	integer min_pw_len = data["format"]:false ? 8 : 1;
	boolean empty_pw_allowed = EmptyCryptPwdAllowed(data);

	string label = _("Don't forget what you enter here!");
	if (empty_pw_allowed)
	    label = label + "\n" + _("Empty password allowed.");

	term contents = `HVSquash(`FrameWithMarginBox(_("Password"),
					 `VBox(
					     `Password(`id(`pw1), `opt(`hstretch),
						       // Label: get password for user root
						       // Please use newline if label is longer than 40 characters
						       _("&Enter a password for your file system:"), ""),
					     `Password(`id(`pw2), `opt(`hstretch),
						       // Label: get same password again for verification
						       // Please use newline if label is longer than 40 characters
						       _("Reenter the password for &verification:"), ""),
					     `VSpacing(0.5),
					     `Left(`Label(label))
					     )
				      )
	    );

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepPasswordHelptext(data));
	MiniWorkflow::SetLastStep(true);

	string password = "";
	symbol widget = nil;

	//don't put those inside the loop - they'd be reset after each unsuccesful try
	UI::ChangeWidget(`id(`pw1), `Value, "");
	UI::ChangeWidget(`id(`pw2), `Value, "");

	string dev = (data["type"]:`unknown != `loop) ? data["device"]:"" 
						      : data["fpath"]:"";
	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    if (widget == `next)
	    {
		password = (string) UI::QueryWidget(`id(`pw1), `Value);
		string tmp = (string) UI::QueryWidget(`id(`pw2), `Value);
		boolean need_verify = !data["format"]:false &&
				      size(data["mount"]:"")>0;

		if (!Storage::CheckEncryptionPasswords(password, tmp, min_pw_len, empty_pw_allowed) ||
		    (need_verify && !Storage::CheckCryptOk(dev, password)) )
		{
		    UI::SetFocus(`id(`pw1) );
		    widget = `again;
		}
		}
		}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    Storage::SetCryptPwd(dev, password);
	    widget = `finish;
	}

	y2milestone("MiniWorkflowStepPassword data:%1 ret:%2", data, widget);

	return widget;
    }


    boolean DlgResize(map <string, any> &data, map <string, any> disk)
    {
	map<string, map> target_map = Storage::GetTargetMap();


	map possible = Storage::IsResizable(data);
	if (!data["format"]:false && !possible["shrink"]:false && !possible["extend"]:false)
	{
	    // popup text
	    Popup::Message(_("
You cannot resize the selected partition because the file system
on this partition does not support resizing.
"));
	    return false;
	}


	integer cyl_size = 0;
	integer free_cyl_after = 0;

	string device = data["device"]:"error";
	symbol used_fs = data["used_fs"]:`none;
	boolean onLvm = ( data["type"]:`unknown == `lvm);


	integer used_k = FileSystems::MinFsSizeK(used_fs);
	if (!data["format"]:false)
	{
	    if (used_fs != `swap)
	    {
		map free_data = Storage::GetFreeSpace(device, 0, used_fs, true);
		if (size(free_data) == 0 || !free_data["ok"]:false)
		{
		    y2error("Failed to retrieve FreeSpace %1, filesystem %2", device, data["used_fs"]:`none);
		    //FIXME: Really?
		    Popup::Error(sformat(_("Partition %1 cannot be resized\nbecause the filesystem seems to be inconsistent"), device));
		    return false;
		}

		used_k = Integer::Max([ used_k, free_data["used"]:0 / 1024 ]);
	    }
	}

	integer min_free_k = 10*1024;

	integer size_k = data["size_k"]:0;

	// minimal and maximal size for volume
	integer min_size_k = Integer::Min([ used_k + min_free_k, size_k ]);
	integer max_size_k = 0;


	string unit = _("MB");
	integer factor = 1024;

	//Depending on size of the partition,
	//set correct division factor and units
	//and minimum required free space, too
	// TODO: get rid of this unit factor and unit altogether
	void AdjustUnits()
	{
	    if (max_size_k > 20*1024*1024)
	    {
		factor = factor * 1024;
		unit = _("GB");
            }
	}


	string heading = "";


	list <string> BarGraphLabels( boolean newlines )
        {
	    string used = "";
	    string free = "";
	    string available = "";

	    switch (data["type"]:`unknown)
	    {
		case `primary:
		case `logical:
		    // Labels for bar graph/text field. Keep it short
		    used = newlines ? _("Used\nSpace") : _("Used Space: ");
		    if (used_fs == `swap)
			// Labels for bar graph/text field. Keep it short
			free = newlines? _("Swap\nSpace") : _("Swap Space: ");
		    else
			// Labels for bar graph/text field. Keep it short
			free = newlines ? _("Free\nSpace") : _("Free Space: ");
		    // Labels for bar graph. Keep it short
		    available = newlines ? _("Unused\nDisk") : _("Unused Disk: ");
		    break;

		case `lvm:
		    // Labels for bar graph/text field. LV stands for 'Logical volume'. Keep it short
		    used = newlines ? _("LV\nUsed") : _("LV Used: ");
		    // Labels for bar graph/text field. LV stands for 'Logical volume'. Keep it short
		    free = newlines ? _("LV\nFree") : _("LV Free: ");
		    // Labels for bar graph/text field. VG stands for 'Volume group'. Keep it short
		    available = newlines ? _("VG\nFree") : _("VG Free: ");
		    break;
	    }

	    return [ used, free, available ];
	}

	switch (data["type"]:`unknown)
	{
	    case `primary:
	    case `logical:
	    {
		// Heading for dialog
		heading = sformat(_("Resize Partition %1"), device);

		cyl_size = disk["cyl_size"]:1;
		free_cyl_after = Storage::FreeCylindersAfterPartition(device);

		min_size_k = Integer::Max([ min_size_k, cyl_size / 1024 ]);
		max_size_k = size_k + (cyl_size * free_cyl_after) / 1024;
	    }
	    break;

	    case `lvm:
	    {
		// Heading for dialog
		heading = sformat(_("Resize Logical Volume %1"), device);

		min_size_k = Integer::Max([ min_size_k, disk["pesize"]:0 / 1024 ]);
		max_size_k = size_k + (disk["pe_free"]:0 * disk["pesize"]:0) / 1024;
	    }
	    break;
	}

	y2milestone("used_k:%1 size_k:%2", used_k, size_k);
	y2milestone("min_size_k:%1 max_size_k:%2", min_size_k, max_size_k);


	AdjustUnits();

	integer slider_size_k = size_k / factor;
	integer slider_min_size_k = min_size_k / factor;
	integer slider_max_size_k = max_size_k / factor;

	term extra_content = `Empty();
	//Spinbox label - %1 will be substituted by unit (GB and alike)
	string newsz = onLvm ? _("New Logical Volume Size (in %1)") : _("New Partition Size (in %1)");

	if (UI::HasSpecialWidget(`BarGraph) && UI::HasSpecialWidget(`Slider))
	{
	    extra_content = `VBox(
		`BarGraph(`id(`graph), `opt(`vstretch), [ slider_min_size_k, slider_size_k - slider_min_size_k,
							  slider_max_size_k - slider_size_k ], BarGraphLabels( true ) ),
		`VSpacing(0.5),
		`Slider(`id(`new_size), `opt(`notify), sformat( newsz, unit),
			slider_min_size_k, slider_max_size_k, slider_size_k)
	    );
	}
	else
	{
	    extra_content = `IntField( `id(`new_size), `opt(`notify), sformat(newsz, unit ),
				 slider_min_size_k, slider_max_size_k, slider_size_k );
	}

	//without newlines
	list <string> other_labels = BarGraphLabels( false );

        UI::OpenDialog(
	    `VBox(
	        `Left(`Heading(heading)),
	        `HSpacing(60),
		`VBox(
		    //Frame label
		    `Frame( onLvm ?  _("Space on Logical Volume ") : _("Space on the Partition"),
			`MarginBox( 0.5, 0.5,
			    `Left(`HBox(
				( used_fs != `swap) ? (
			        `HBox( 
				    `Label( other_labels[0]:""),
			            `Label(`id(`used), `opt(`outputField), Storage::KByteToHumanString( min_size_k)),
			            `HSpacing(0.5)) 
				)  : `Empty(),

			        `Label( other_labels[1]:""),
				`ReplacePoint(`id(`r2),
			            `Label(`id(`free),`opt(`outputField), Storage::KByteToHumanString(size_k - min_size_k))
				),
			        `HSpacing(0.5),

			        `Label( other_labels[2]:""),
				`ReplacePoint(`id(`r3),
			            `Label(`id(`unused),`opt(`outputField), Storage::KByteToHumanString( max_size_k - size_k))
				)
			    ))
		        )
		    )
		),
		 extra_content,
		`VSpacing(1.0),
		//Frame label
		`Frame ( onLvm ?  _("LV Size Restrictions") : _("Partition Size Restrictions"),
		    `MarginBox(0.5, 0.5,
			`Left(`HBox(
			    //text field label
	                    `Label( onLvm ? _("Minimum LV Size") : _("Minimum Partition Size: ")),
		            `Label(`opt(`outputField), Storage::KByteToHumanString(min_size_k)),
		            `HSpacing(0.5),
			    //text field label
	                    `Label( onLvm ? _("Maximum LV Size") : _("Maximum Partition Size: ")),
			    `Label(`opt(`outputField), Storage::KByteToHumanString(max_size_k))
			    ))
		    )
		),
		`ButtonBox(
		    `PushButton(`id(`help), `opt(`helpButton), Label::HelpButton()),
		    `PushButton(`id(`cancel), `opt(`cancelButton), Label::CancelButton()),
		    `PushButton(`id(`ok), `opt(`default, `okButton), Label::OKButton())
		)
	    )
	);

	// help text
	string help_text = _("<p>Choose the new size by dragging the slider or by entering a
numeric value in either input field.</p>");

	UI::ChangeWidget(`help, `HelpText, help_text);


	symbol widget = nil;

	integer old_size_k = size_k;

	do {

	    widget = (symbol) UI::UserInput();

	    switch (widget)
	    {
	        case `new_size:
	        {
		    slider_size_k = (integer) UI::QueryWidget(`id(`new_size), `Value);
		    size_k = Integer::Clamp(slider_size_k * factor, min_size_k, max_size_k);

		    UI::ChangeWidget(`id(`graph), `Values, [ slider_min_size_k, slider_size_k - slider_min_size_k,
							     slider_max_size_k - slider_size_k ]);


		    //Replacing widgets, rather than just changing value. It is clumsy, but UI sets value
		    //of the label without adjusting its size. RecalcLayout makes ncurses flicker insanely.
		    //ReplaceWidget does, too, but not so much
		    UI::ReplaceWidget(`id(`r2), `Label(`opt(`outputField), Storage::KByteToHumanString( size_k - min_size_k )) );
		    UI::ReplaceWidget(`id(`r3), `Label(`opt(`outputField), Storage::KByteToHumanString( max_size_k - size_k )) );

		    break;
	        }

	        case `ok:
	        {
		    if (size_k != old_size_k)
		    {
			string mountpoint = data["inactive"]:false ? "" : data["mount"]:"";
			boolean lvm = data["type"]:`unknown == `lvm;

			//1 - ask & be interactive, 2 - we are on lvm, 3 - cyl.diff, 4 - filesystem, 5 - mountpoint
			if (!CheckResizePossible(false, lvm, size_k - old_size_k, used_fs, mountpoint))
			{
			    //FIXME: To check whether the part. can be resized only
			    //after user tries to do that is stupid - in some cases
			    //we can tell beforehand, thus user should never get to this
			    //point (e.g. when the partition is mounted)
			    y2error("Resizing the partition is not possible");
			    widget = `again;
			    continue;
			}

			switch (data["type"]:`unknown)
			{
			    case `primary:
			    case `logical:
				data["region", 1] = Integer::Clamp(PartedSizeToCly((tofloat(size_k*1024)), cyl_size),
								   1, data["region", 1]:0 + free_cyl_after);
				break;

			    case `lvm:
				data["size_k"] = size_k;
				break;
			}
		    }
		    break;
	        }

		case `cancel:
		    break;
	    }

	} while (widget != `cancel && widget != `ok);

	UI::CloseDialog();

	return widget == `ok;
    }


    void DisplayCommandOutput(string command)
    {
	// TODO: maybe use LogView.ycp, but here we want to wait until the command has finished
	// TODO: better error handling

	UI::OpenDialog(`VBox(
			   // label for log view
			   `MinWidth(60, `LogView(`id(`log), sformat(_("Output of %1"), command), 15, 0)),
			   `PushButton(`opt(`default), Label::CloseButton())
			   ));

	map tmp = (map) SCR::Execute(.target.bash_output, command);

	string lines = tmp["stderr"]:"" != "" ? tmp["stderr"]:"" : tmp["stdout"]:"";
	UI::ChangeWidget(`id(`log), `Value, lines);

	UI::UserInput();
	UI::CloseDialog();
    }


    void RescanDisks()
    {
	UI::OpenDialog(`opt(`decorated),
		       // popup text
		       `MarginBox(2, 1, `Label(_("Rescanning disks..."))));

	Storage::ReReadTargetMap();

	UI::CloseDialog();
    }
}
