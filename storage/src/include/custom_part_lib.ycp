/*************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Johannes Buchhold <jbuch@suse.de>
 *
 * Description:   lib
 *
 *
 *************************************************************
 *
 $Id$
 *
*/

{
  textdomain "storage";
  import "Mode";
  import "Arch";
  import "Partitions";
  import "Product";
  import "FileSystems";

  include "partitioning/partition_defines.ycp";

define string mountVar( map var, map root, string rdev, string mp, 
                        map<string,map> targetMap )
    ``{
    string ret = "";
    boolean mount_success = false;
    y2milestone( "mountVar rdev:%1 mp:%2 var:%3 root:%4", rdev, mp, var, root );
    if( var["size_k"]:0>0 )
	{
	ret = var["device"]:"";
	}
    else
	{
	list<string> ds = maplist( string d, map disk, targetMap, ``(d));
	y2milestone( "mountVar ds:%1", ds );
	ds = filter( string d, ds, ``(targetMap[d,"type"]:`CT_UNKNOWN==`CT_DISK));
	y2milestone( "mountVar ds:%1", ds );
	map rootm = Storage::GetDiskPartition( rdev );
	map rootf = Storage::GetDiskPartition( root["device"]:"" );
	map varf = Storage::GetDiskPartition( var["device"]:"" );
	if( rootf["disk"]:""==varf["disk"]:"" )
	    {
	    ret = Storage::GetDeviceName( rootm["disk"]:"", varf["nr"]:(any)0 );
	    }
	else if( size(ds)==1 )
	    {
	    ret = Storage::GetDeviceName( ds[0]:"", varf["nr"]:(any)0 );
	    }
	else if( size(ds)>1 )
	    {
	    integer i = 0;
	    while( i<size(ds) && size(ret)==0 )
		{
		ret = Storage::GetDeviceName( ds[i]:"", varf["nr"]:(any)0 );
		if( size(Storage::GetPartition( targetMap, ret ))>0 &&
		    Storage::Mount( ret, mp ) )
		    {
		    map d = (map)SCR::Read( .target.stat, mp+"/lib/hardware" );
		    y2milestone( "mountVar d:%1", d );
		    if( !d["isdir"]:false )
			ret = "";
		    Storage::Umount( ret );
		    }
		else 
		    ret = "";
		i = i+1;
		}
	    }
	}
    if( size(ret)>0 && !Storage::Mount( ret, mp ))
	ret = "";
    y2milestone( "mountVar ret:%1", ret );
    return( ret );
    }


  /**
   * Find and read fstab by installation. Scan existing partitions.
   * @parm targetMap all targets
   * @parm search_point mount point where partitions can be mounted
   * @return list list with fstab data found
   */
define list<list> findExistingFstab( map<string,map> targetMap, string search_point )
    ``{
    /////////////////////////////////////////////////////////////////
    // foreach partition on each target
    list<list> fstab = [];
    list skip_fs = [ `unknown, `swap, `vfat, `ntfs ];

    foreach( string dev, map disk, targetMap,
	``{
	foreach( map part,
	         filter( map p, disk["partitions"]:[],
				``(!contains( skip_fs, 
				              p["detected_fs"]:`unknown) )),
	    ``{
	    /////////////////////////////////////////////////////
	    // try to mount
	    boolean mount_success = Storage::Mount( part["device"]:"",
	                                            search_point );

	    if( mount_success &&
		SCR::Read(.target.size, search_point+"/etc/fstab") > 0 )
		{
		list<map> tmp = 
		    (list<map>)Storage::ReadFstab( search_point+"/etc" );
		y2milestone( "findExistingFstab fstab %1", tmp );
		if( size(tmp)>0 )
		    {
		    if( find( map p, tmp, ``(p["size_k"]:0==0 ))!=nil )
			{
			string vardev = "";
			map var = find( map p, tmp, ``(p["mount"]:""=="/var"));
			map root = find( map p, tmp, ``(p["mount"]:""=="/"));
			y2milestone( "findExistingFstab var %1", var );
			if( var != nil )
			    {
			    vardev = mountVar( var, root, part["device"]:"", 
			                       search_point+"/var", targetMap );
			    y2milestone( "findExistingFstab vardev %1", 
			                 vardev );
			    }
			map dmap = Storage::BuildDiskmap( $[] );
			if( size(dmap)>0 )
			    {
			    y2milestone( "findExistingFstab dmap %1", dmap );
			    y2milestone( "findExistingFstab tmp %1", tmp );
			    tmp = maplist( map p, tmp, 
				``{
				if( p["size_k"]:0 == 0 )
				    p["device"] = Storage::HdDiskMap( p["device"]:"", dmap );
				return( p );
				});
			    y2milestone( "findExistingFstab tmp %1", tmp );
			    }
			integer s = size(tmp);
			tmp = filter( map p, tmp, ``(Storage::CanEdit(p,false)));
			if( s!=size(tmp) )
			    y2milestone( "findExistingFstab tmp %1", tmp );
			if( size(vardev)>0 )
			    Storage::Umount( vardev );
			}
		    fstab = add( fstab, tmp );
		    }
		}

	    /////////////////////////////////////////////////////
	    // unmount
	    if( mount_success )
		Storage::Umount( part["device"]:"" );
	    });
	});
    y2milestone( "findExistingFstab count_fstab_found %1", size(fstab) );
    y2milestone( "findExistingFstab fstab %1", fstab );
    return fstab;
    };


/**
  * Scan and Read and return fstab.
  * @parm targetMap all targets
  * @parm file_systems filesystem map
  * @return list list with fstab
  */
define list<list> scanAndReadExistingFstab( map<string,map> targetMap )
    ``{
    string search_point = "/mnt";

    /////////////////////////////////////////////////////////////////
    // make search dir

    if( SCR::Execute(.target.bash, "/usr/bin/test -d " + search_point ) != 0)
	{
	SCR::Execute(.target.mkdir, search_point );
	}

    list<list> fstab = findExistingFstab( targetMap, search_point );

    return fstab;
    };


  /**
   * Check lvm mount points
   * @param mount mount point
   * @return boolean
   */
define boolean check_lvm_mount_points( string mount )
    ``{
    list not_allowed_lvm_mount_points  = [ Partitions::BootMount() ];
    y2milestone( " check lvm mount");
    if( contains( not_allowed_lvm_mount_points, mount ))
        {
        // error popup text
	Popup::Error(sformat(_("You cannot use the mount point \"%1\" for LVM.\n"), Partitions::BootMount()));

	    return false;
	}
    return true;
    };


  /**
   * Check raid mount points
   * @param mount mount point
   * @return boolean
   **/
define boolean check_raid_mount_points( string mount )
    ``{
	list not_allowed_raid_mount_points  = [ ];
	if( Arch::ppc () || Arch::s390 () || Arch::sparc () )
	    {
	    not_allowed_raid_mount_points =
		add( not_allowed_raid_mount_points, Partitions::BootMount() );
	    }
	y2milestone( " check raid mount");
	if( contains( not_allowed_raid_mount_points, mount ))
	{
           // error popup text
	    Popup::Error(sformat(_("You cannot use the mount point %1 for RAID."), Partitions::BootMount()));

	    return false;
	}
	return true;
    };



  /**
   * Check if the noauto option is permitted for this mount point.
   * @param mount mount point
   * @return boolean
   **/
define boolean check_noauto_mount( string mount )
    ``{
    boolean ret = true;
    if( FileSystems::IsSystemMp( mount, true ) )
	{
        // error popup text
	ret = Popup::YesNo(
_("You have selected not to mount automatically at start-up a file system
that may contain files that the system needs to work properly.

This might lead to trouble.

Really do this?
"));
	y2milestone( "ret %1", ret );
	}
    return ret;
    };

  /**
   * Check crypted mount points and return true if the mount point is ok.
   * @param mount mount point
   * @param crypt_fs boolean
   * @return boolean
   **/
define boolean check_crypt_fs_mount_points( string mount, boolean crypt_fs )
    ``{
    if( crypt_fs && FileSystems::IsCryptMp( mount, false ))
	{
        // error popup text
	Popup::Error(
_("You have assigned an encrypted file system to a partition
with one of the following mount points: \"/\", \"/usr\", \"/boot\",
\/var\".  This is not possible. Change the mount point or use a
nonloopbacked file system.
"));
	    return false;
	}
    return true;
    };


    /**
     * Check all label and return true if the label is unique.
     * @param targetMap the TargetMap
     * @param part      partition to check
     * @return boolean
     **/
define boolean check_unique_label( map<string,map> targetMap, map part )
    ``{
    boolean unique = true;

    // check if the label is already in use
    foreach( string disk, map diskinfo, targetMap, ``{
	foreach( map p, diskinfo["partitions"]:[], ``{
	    if ( p["device"]:"" != part["device"]:"" )
		{
		// all valid partitions
		if ( p["label"]:"" == part["label"]:"" ) unique = false;
		}
	    });
	});
    return( unique );
    };

define boolean CheckFstabOptions( map part )
    ``{
    boolean ret = true;
    if( FileSystems::IsSystemMp( part["mount"]:"", true ) &&
        FileSystems::HasFstabOption( part, "user", false ) )
	{
        // error popup text
	ret = Popup::YesNo(
_("You have set the option to be mountable by users for a file system
that may contain files that need to be executable.

This usually causes problems.

Really do this?
"));
	y2milestone( "system mp user ret %1", ret );
	}
    if( ret && part["noauto"]:false )
	{
	ret = check_noauto_mount( part["mount"]:"" ) && ret;
	}
    y2milestone( "CheckFstabOptions ret %1 part %2", ret, part );
    return( ret );
    }

    /**
     * Check all mount points and return true if the mount point is ok.
     * @param targetMap the TargetMap
     * @param mount mount point
     * @return boolean
     **/
define boolean check_mount_point( map<string,map> targetMap, string dev,
                                  map part )
{
    string mount = part["mount"]:"";
    symbol used_fs = part["used_fs"]:`unknown;
    y2milestone( "check_mount_point part:%1", part );

    boolean allowed = true;
    list not_allowed_system_mount_points  =
	[ "/proc", "/dev", "/mnt", "/var/adm/mnt", "/lost+found", "/lib",
	  "/bin", "/etc", "/sbin" ];

    if (mount == "")
    {
	Popup::Error(_("Mount point must not be empty."));
	allowed = false;
    }
    else if (used_fs == `swap && mount != "swap")
    {
	allowed = false;
	// error popup
	Popup::Error(_("Swap devices must have swap as mount point."));
    }
    else if (used_fs != `swap && mount == "swap")
    {
	allowed = false;
	// error popup
	Popup::Error(_("Only swap devices may have swap as mount point."));
    }
    else if (mount != "swap" || part["type"]:`unknown == `loop)
	{
	// check if the mount point is already in use
	foreach( string disk, map diskinfo, targetMap, ``{
	    foreach( map part, diskinfo["partitions"]:[], ``{
		if( part["device"]:"" != dev )
		    {
		    // all valid partitions
		    if ( part["mount"]:"" == mount ) allowed = false;
		    }
		});
	    });

	if( allowed == false && mount!="swap" )
	    {
	    // error popup text
	    Popup::Error(_("This mount point is already in use. Select a different one."));
	    }
	// check if a dos filesystem is used for system purposes
	else if( used_fs == `vfat &&
		 (mount == "/" || mount == "/usr" || mount == "/opt" ||
		  mount == "/var" || mount == "/home"))
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("FAT filesystem used for system mount point (/, /usr, /opt, /var, /home).\nThis is not possible."));
	    }
	// check if the mount countains chars making trouble
	else if( findfirstof( mount, " `'´!\"%#" ) != nil )
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("Invalid character in mount point. Do not use \"`'!\"%#\" in a mount point."));
	    }

	// check if the mount point is a system mount point
	else if ( contains( not_allowed_system_mount_points , mount) )
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("You cannot use any of the following mount points:
/proc, /dev, /lib, /bin, /etc, /sbin, /mnt, /var/adm/mnt, /lost+found
"));
	    }
	else if ( substring( mount, 0, 1 ) != "/"  )
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("Your mount point must start with a \"/\" "));
	    }
	}
    else if( !part["format"]:false && part["detected_fs"]:`none != `swap )
	{
	// error popup text
string message = _("
WARNING:

You chose a swap partition but did not direct YaST2 to format it.
This swap partition will probably not be usable.

Change the setup?
");

	allowed = !Popup::YesNo(message);
	}

    if( allowed )
	{
	allowed = CheckFstabOptions( part );
	}
    return allowed;
}


boolean
check_ok_fssize(integer size_k, map volume)
{
    boolean ret = true;

    symbol fs = volume["used_fs"]:`unknown;
    integer min_size_k = FileSystems::MinFsSizeK(fs);
    y2milestone("check_ok_fssize fs:%1 size_k:%2 min_size_k:%3", fs, size_k, min_size_k);

    if (size_k < min_size_k)
    {
	// warning message, %1 is replaced by fs name (e.g. Ext3)
	// %2 is prelaced by a size (e.g. 10 MB)
	Popup::Warning(sformat(_("Your partition is too small to use %1.
The minimum size for this file system is %2.
"), FileSystems::GetName(fs, ""), Storage::KByteToHumanString(min_size_k)));

	ret = false;
    }

    return ret;
}


    /**
     * Do all checks concerning mount points, uuid, volume labels and
     * fstab options
     * @param targetMap the TargetMap
     * @param mount mount point
     * @return map
     **/
define map CheckOkMount( string dev, map old, map<string,any> new )
    ``{
    y2milestone( "CheckOkMount old:%1 new:%2", old, new );
    map ret = $[];
    ret["ok"] = true;
    new["mount"] = UI::QueryWidget(`id(`mount_point), `Value);
    if( old["mount"]:"" != new["mount"]:"" )
	new["inactive"] = true;
    if( ret["ok"]:false )
	{
	boolean crypt_fs = false;
	if( !check_mount_point( Storage::GetTargetMap(), dev, new ))
	    {
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	if( UI::WidgetExists( `id(`crypt_fs) ))
	    {
	    crypt_fs = (boolean)UI::QueryWidget(`id(`crypt_fs), `Value );
	    }
	if( !check_crypt_fs_mount_points(new["mount"]:"", crypt_fs ))
	    {
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	if( new["noauto"]:false && !check_noauto_mount( new["mount"]:"" ))
	    {
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	if( new["type"]:`primary == `sw_raid )
	    {
	    if( !check_raid_mount_points(new["mount"]:""))
		{
		ret["ok"] = false;
		ret["field"] = `mount_point;
		}
	    }
	else if( new["type"]:`primary == `lvm )
	    {
	    if( !check_lvm_mount_points(new["mount"]:""))
		{
		ret["ok"] = false;
		ret["field"] = `mount_point;
		}
	    }
	if( !new["format"]:false && !crypt_fs &&
	    contains( [`unknown, `none], new["detected_fs"]:`unknown ))
	    {
	    // error popup text
	    Popup::Error(_("It is not allowed to assign a mount point
to a device with nonexistent or unknown file system."));
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	}
    if( !new["format"]:false )
	{
	new = filter(string key, any value, new, ``(key != "fs_options"));
	}
    y2milestone( "ret:%1 new:%2", ret, new );
    ret["map"] = new;
    return( ret );
    };

define boolean EmptyCryptPwdAllowed( map p )
    {
    boolean ret = p["format"]:false && 
	contains(union(FileSystems::tmp_m_points, FileSystems::swap_m_points), p["mount"]:"");
    ret = ret && Storage::IsPersistent( p );
    y2milestone( "EmptyCryptPwdAllowed ret:%1", ret );
    return( ret );
    }


/**
  * Do all checks concerning handling of crypt fs
  * @param new partition map
  * @return map
  **/
define map CheckCryptOk( map new )
    ``{
    map ret = $[ "ok" : true ];
    boolean crypt_fs = false;
    if( UI::WidgetExists( `id(`crypt_fs) ))
	{
	crypt_fs = (boolean)UI::QueryWidget(`id(`crypt_fs), `Value );
	}
    if( crypt_fs )
	new["enc_type"] = new["format"]:false?`luks:`twofish;
    else
	new["enc_type"] = `none;
    if( crypt_fs && size(Storage::GetCryptPwd( new["device"]:"" ))==0 )
	{
	boolean tmpc = EmptyCryptPwdAllowed( new );
	string fs_passwd = DlgCreateCryptFs( new["device"]:"", 
	                                     new["format"]:false?8:1, 
					     new["format"]:false, tmpc );
	// Ask the user for a password for cryptofs, else set crypto to nil??
	if( fs_passwd != nil && size(fs_passwd)>0 )
	    {
	    string dev = new["device"]:"";
	    boolean popup = !new["format"]:false;
	    y2milestone( "CheckCryptOk dev %1 popup %2", dev, popup );
	    if( popup )
		UI::OpenDialog( `opt(`decorated),
			        `VBox(
				     `VSpacing(1),
				    `HBox(`HSpacing(1), 
					  `Label(_("Detecting encryption type...")),
					  `HSpacing(1)),
				     `VSpacing(1)));

	    ret["ok"] = Storage::SetCryptPwd( dev, fs_passwd ) && 
	                (new["format"]:false ||
			 Storage::SetCrypt( dev, true, new["format"]:false ));
	    if( ret["ok"]:false && new["type"]:`unknown == `loop )
		Storage::UpdateClassified( new["fpath"]:"", fs_passwd );
	    if( popup )
		UI::CloseDialog();
	    }
	else
	    {
	    ret["ok"] = tmpc;
	    }
	}
    ret["map"] = new;
    y2milestone( "CheckCryptOk ret:%1", ret );
    return( ret );
    };

define map CheckFormatOk( map new )
    ``{
    map ret = $[ "ok" : true ];
    if( new["format"]:false )
	{
	symbol ufs = new["used_fs"]:`unknown;
	y2milestone( "GetSupportFormat %1", FileSystems::GetSupportFormat(ufs));
	if( !FileSystems::GetSupportFormat(ufs) )
	    {
	    // Popup text
	    string txt = sformat( "The file system of type %1 cannot be created.", 
	                          FileSystems::GetName( ufs, "" ));
	    Popup::Error(txt);
	    ret["ok"] = false;
	    }
	}
    ret["map"] = new;
    y2milestone( "CheckFormatOk ret:%1", ret["ok"]:false );
    return( ret );
    };

define map CheckDeviceFinalOk( map new )
    ``{
    y2milestone( "CheckDeviceFinalOk new:%1", new );
    map ret = CheckFormatOk( new );
    if( ret["ok"]:false )
	{
	ret = CheckCryptOk( ret["map"]:$[] );
	}
    y2milestone( "CheckDeviceFinalOk ret:%1", ret );
    return( ret );
    }

map pkg_for_fs = $[
    `ext2 : [ "e2fsprogs" ],
    `ext3 : [ "e2fsprogs" ],
    `ext4 : [ "e2fsprogs" ],
    `btrfs : [ "btrfsprogs" ],
    `reiser : [ "reiserfs" ],
    `vfat : [ "dosfstools" ],
    `ntfs : [ "ntfsprogs" ],
    `jfs : [ "jfsutils" ],
    `xfs : [ "xfsprogs" ] ];

define map<string,any> HandleFsChanged( boolean init, map<string,any> new, 
                                        symbol old_fs, map file_systems )
    ``{
    boolean apply_change = true;
    list<string> not_used_mp = [];
    symbol used_fs = new["used_fs"]:`unknown;
    map selected_fs = file_systems[used_fs]:$[];
    y2milestone( "HandleFsChanged init:%1 used_fs:%2 old_fs:%3 new:%4",
                 init, used_fs, old_fs, new );

    if( !init && used_fs != old_fs )
	{
	y2milestone( "HandleFsChanged IsUnsupported:%1", 
	             FileSystems::IsUnsupported( used_fs ));
	if( FileSystems::IsUnsupported( new["used_fs"]:`unknown ))
	    {
	    // warning message, %1 is replaced by fs name (e.g. Ext3)
	    string message = sformat(_("
WARNING:

This file system is not supported in %1;.
It is completely untested and might not be well-integrated 
in the system.  Do not file bugs against the file system 
itself if it does not work properly or at all.

Really use this file system?
"), Product::name );

	    apply_change = Popup::YesNo(message);
	    }
	if( apply_change && !Stage::initial() )
	    {
	    if( size(pkg_for_fs[used_fs]:[])>0 )
		{
		boolean r = Package::InstallAll( pkg_for_fs[used_fs]:[] );
		y2milestone( "HandleFsChanged install %1 ret:%2", 
		             pkg_for_fs[used_fs]:[], r );
		if( !r )
		    apply_change = false;
		}
	    }
	if( !apply_change )
	    {
	    new["used_fs"] = old_fs;
	    UI::ChangeWidget(`id(`fs), `Value, old_fs );
	    }
	}

    if( apply_change && UI::WidgetExists( `id(`crypt_fs) ))
	{
	boolean cr = selected_fs[`crypt]:true;

	UI::ChangeWidget( `id(`crypt_fs), `Enabled, cr );
	if( !cr )
	    {
	    y2milestone( "HandleFsChanged crypt set to false" );
	    UI::ChangeWidget(`id(`crypt_fs), `Value, false );
	    }
	}

    if( apply_change )
	{
	////////////////////////////////////////////////
	// switch between swap and other mountpoints
	string mount = (string)UI::QueryWidget( `id(`mount_point), `Value);
	new["mount"] = mount;
	if( used_fs == `swap )
	    {
	    not_used_mp = selected_fs[`mountpoints]:[];
	    if( mount != "swap" && (new["type"]:`primary!=`lvm || mount!=""))
		{
		new["mount"] = "swap";
		new["inactive"] = true;
		}
	    }
	else
	    {
	    not_used_mp =
		notUsedMountpoints( Storage::GetTargetMap(),
				    selected_fs[`mountpoints]:[] );
	    if( new["type"]:`primary == `lvm ||
		(new["type"]:`primary == `sw_raid&&
		 new["raid_type"]:"raid0"!="raid1") )
		{
		not_used_mp = filter( string mp, not_used_mp,
				      ``( mp != Partitions::BootMount() ));
		}
	    else if( new["type"]:`primary == `loop )
		{
		not_used_mp =
		    filter( string mp, not_used_mp,
			    ``(!contains( FileSystems::system_m_points, mp)));
		}
	    if(mount == "swap")
		new["mount"] = "";
	    }
	// UI::ReplaceWidget(`id(`mount_dlg_rp), MountDlg( new, not_used_mp));
	UI::ChangeWidget( `id(`mount_point), `Value, new["mount"]:"" );

	UI::ChangeWidget( `id(`fstab_options), `Enabled, 
	                  size(new["mount"]:"")>0 );
	if( UI::WidgetExists( `id(`fs_options) ))
	    UI::ChangeWidget(`id(`fs_options), `Enabled,
			     new["format"]:false && selected_fs[`options]:[]!=[] );
	string fstopt = FileSystems::DefaultFstabOptions( new );
	if( size(fstopt)>0 && size(new["fstopt"]:"")==0 )
	    new["fstopt"] = fstopt;
	new["fs_options"] = FileSystems::DefaultFormatOptions(new);
	if( !init )
	    {
	    new["fstopt"] = fstopt;

	    integer max_len = FileSystems::LabelLength( used_fs );
	    if( size(new["label"]:"") > max_len )
		{
		new["label"] = substring( new["label"]:"", 0, max_len );
		}
	    symbol mountby = new["mountby"]:`device;
	    if( (mountby == `uuid && !FileSystems::MountUuid( used_fs )) ||
		(mountby == `label && !FileSystems::MountLabel( used_fs )) )
		{
		new["mountby"] = `device;
		}
	    if( !FileSystems::MountLabel( used_fs ) && size(new["label"]:"")>0 )
		{
		new["label"] = "";
		}
	    }
	}
    y2milestone( "HandleFsChanged new %1", new );
    return( new );
    };


define map<string,any> HandlePartWidgetChanges( boolean init, any ret,
                                                map file_systems,
						map<string,any> old,
						map<string,any> new )
    ``{
    y2milestone( "HandlePartWidgetChanges init:%1 ret:%2 new:%3",
                 init, ret, new );
    symbol used_fs = new["used_fs"]:`unknown;
    map selected_fs = file_systems[used_fs]:$[];
    /////////////////////////////////////////////////////////
    // configure main dialog and modify map new
    if( !init && new["mount"]:"" != old["mount"]:"" )
	{
	if( Arch::ia64 () && new["mount"]:"" == Partitions::BootMount() )
	    {
	    new = filter(string key, any value, new, ``( key != "fstopt"));
	    }
	}
    if( !init && ret == `mount_point &&
        UI::WidgetExists( `id(`fstab_options) ))
	{
	string mp = (string)UI::QueryWidget(`id(`mount_point), `Value);
	UI::ChangeWidget( `id(`fstab_options), `Enabled, size(mp)>0 );
	}
    if( (init && UI::WidgetExists( `id(`format))) ||
        ret == `do_format || ret == `do_not_format)
	{
	boolean format = UI::QueryWidget(`id(`format), `Value) == `do_format;

	boolean old_format = new["format"]:false;

	////////////////////////////////////////////////
	// format partition
	new["format"] = format;

	if( old_format != format )
	    {
	    symbol dfs = `unknown;
	    if( format )
		{
		dfs = (symbol)UI::QueryWidget(`id(`fs), `Value);
		}
	    else
		{
		if( new["detected_fs"]:`unknown != `unknown )
		    {
		    dfs = new["detected_fs"]:Partitions::DefaultFs();
		    }
		else
		    {
		    dfs = new["used_fs"]:Partitions::DefaultFs();
		    }
		UI::ChangeWidget( `id(`fs), `Value, dfs );
		}
	    map selected_fs = file_systems[dfs]:$[];
	    new["used_fs"] = dfs;
	    y2milestone( "HandlePartWidgetChanges used_fs %1", dfs );
	    if( new["used_fs"]:`unknown != old["used_fs"]:`unknown )
		new = HandleFsChanged( init, new, old["used_fs"]:`unknown,
		                       file_systems );
	    if( format )
		{
		new["fs_options"] = FileSystems::DefaultFormatOptions(new);
		if( !contains( selected_fs[`alt_fsid]:[], new["fsid"]:0 ))
		    new["fsid"] = selected_fs[`fsid]:Partitions::fsid_native;
		}
	    else
		{
		if( haskey( new, "ori_fsid" ) )
		    {
		    new["fsid"] = new["ori_fsid"]:0;
		    }
		else
		    {
		    new["fsid"] = old["fsid"]:0;
		    }
		}
	    if( UI::WidgetExists( `id(`fsid_point) ))
		{
		if( size(selected_fs)>0 &&
		    new["fsid"]:0 != selected_fs[`fsid]:0 &&
		    !contains( selected_fs[`alt_fsid]:[], new["fsid"]:0 ))
		    {
		    UI::ChangeWidget( `id(`fsid_point), `Value,
				      selected_fs[`fsid_item]:"" );
		    }
		}
	    if( !format )
		{
		new["fs_options"] = $[];
		}
	    new["fstopt"] = FileSystems::DefaultFstabOptions( new );
	    }
	}
    if( init || ret == `fs )
	{
	symbol new_fs = used_fs;
	if( UI::WidgetExists( `id(`fs) ))
	    new_fs = (symbol)UI::QueryWidget(`id(`fs), `Value);
	if( init )
	    {
	    if( !new["format"]:false && new["detected_fs"]:`unknown != `unknown )
		new_fs = new["detected_fs"]:`unknown;
	    else if( new["fsid"]:0 == Partitions::fsid_gpt_boot )
		new_fs = `vfat;
	    if( used_fs != new_fs )
		UI::ChangeWidget(`id(`fs), `Value, new_fs );
	    }
	y2milestone( "HandlePartWidgetChanges init=%1 used_fs:%2 new_fs:%3",
	             init, used_fs, new_fs );
	if( init || used_fs != new_fs )
	    {
	    map selected_fs = file_systems[new_fs]:$[];
	    new["used_fs"] = new_fs;

	    new = HandleFsChanged( init, new, used_fs, file_systems );

	    if( !init )
		{
		if( !contains( selected_fs[`alt_fsid]:[], new["fsid"]:0 ))
		    new["fsid"] = selected_fs[`fsid]:Partitions::fsid_native;
		y2milestone( "HandlePartWidgetChanges fsid %1", new["fsid"]:0 );
		if( UI::WidgetExists( `id(`fsid_point) ))
		    {
		    UI::ChangeWidget( `id(`fsid_point), `Value,
				      selected_fs[`fsid_item]:"");
		    }
		}
	    }
	}
    if( (init && UI::WidgetExists(`id(`fsid_point))) || ret == `fsid_point )
	{
	////////////////////////////////////////////////
	// modify map new
	string fs_string = (string)UI::QueryWidget(`id(`fsid_point), `Value);
	y2milestone("HandlePartWidgetChanges fs_string:%1", fs_string );
	fs_string        = substring( fs_string, 0, 5  );
	integer fs_int   = tointeger( fs_string );
	integer old_id   = new["fsid"]:0;

	y2milestone( "HandlePartWidgetChanges fs_int:%1 old_id:%2",
	             fs_int, old_id );

	if( fs_int != old_id )
	    {
	    new["fsid"] = fs_int;
	    boolean no_fs = contains( [ Partitions::fsid_lvm,
	                                Partitions::fsid_raid,
					Partitions::fsid_hibernation,
					Partitions::fsid_prep_chrp_boot ],
				      fs_int );

	    UI::ChangeWidget( `id(`fstab_options), `Enabled, !no_fs );
	    UI::ChangeWidget( `id(`do_format), `Enabled, !no_fs );
	    UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, !no_fs);
	    if( no_fs )
		{
		UI::ChangeWidget( `id(`do_not_mount), `Value, true);
		ChangeExistingSymbolsState( [ `fs_options, `fs ], false );
		}
	    else if( fs_int == Partitions::fsid_native )
		{
		new["used_fs"] = Partitions::DefaultFs();
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, Partitions::DefaultFs(),
		                       file_systems );
		}
	    else if( fs_int == Partitions::fsid_swap )
		{
		new["used_fs"] = `swap;
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, `swap, file_systems );
		}
	    else if( contains( Partitions::fsid_wintypes, fs_int ) ||
	             fs_int==Partitions::fsid_gpt_boot )
		{
		new["mount"] = "";
		new["used_fs"] = `vfat;
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, `vfat, file_systems );
		}
	    else if( fs_int == Partitions::fsid_mac_hfs )
		{
		new["mount"] = "";
		new["used_fs"] = `hfs;
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, `hfs, file_systems );
		}
	    }
	}
    if( ret == `fstab_options )
	{
	new["mount"] = UI::QueryWidget( `id(`mount_point), `Value );
	new = FstabOptions( old, new );
	}
    if( ret == `crypt_fs )
	{
	boolean val = (boolean)UI::QueryWidget( `id(`crypt_fs), `Value );
	new["enc_type"] = val?(new["format"]:false?`twofish:`twofish_old):`none;
	if( val )
	    {
	    new["mountby"] = `device;
	    new["label"] = "";
	    new["ori_label"] = "";
	    if( !Stage::initial() )
		Package::InstallAll( ["cryptsetup", "pam_mount"] );
	    }
	}
    if( ret == `fs_options )
	{
	new["fs_options"] = FileSystemOptions( new["fs_options"]:$[],
	                                       selected_fs );
	}
    if( Mode::repair () )
        {
	UI::ChangeWidget(`id(`do_mount), `Enabled, false);
	UI::ChangeWidget(`id(`do_not_mount), `Enabled, false);
	UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, false);
        UI::ChangeWidget(`id(`fstab_options), `Enabled, false);
        UI::ChangeWidget(`id(`crypt_fs) ,     `Enabled, false);
        }
    y2milestone( "HandlePartWidgetChanges old:%1", old );
    y2milestone( "HandlePartWidgetChanges new:%1", new );
    return( new );
    };

/**
 * Merge readed list fstab with targetMap
 * @parm targetMap all targets
 * @parm fstab readed fstab list
 * @return return ( [ targetMap, table_input ]
 *
 */
define list AddFstabToData( map<string,map> targetMap, list<map> fstab )
    ``{
    if( fstab == nil )
	return [targetMap] ;

    y2milestone( "AddFstabToData fstab = %1", fstab );

    map new_targetMap = targetMap;
    map table_input = $["tbl":[]];

    foreach( string dev, map disk, targetMap,
	``{
	list new_partitions = [];
	map target = disk;
	foreach( map partition, disk["partitions"]:[],
	    ``{
	    map new_partition = partition;

	    foreach( map fstab_entry, fstab,
		``{
		string dev_fstab   = fstab_entry["device"]:"";
		string mount_fstab = fstab_entry["mount"]:"";
		boolean found = false;

		if( dev_fstab == partition["device"]:"" )
		    {
		    found = true;
		    }
		if( found )
		    {
		    new_partition["mount"] = mount_fstab;
		    if( size(fstab_entry["fstopt"]:"")>0 &&
			fstab_entry["fstopt"]:"" != "default" )
			{
			new_partition["fstopt"] = fstab_entry["fstopt"]:"";
			}
		    if( fstab_entry["mountby"]:`device != `device )
			new_partition["mountby"] = fstab_entry["mountby"]:`device;
		    if( fstab_entry["enc_type"]:`none != `none )
			new_partition["enc_type"] = fstab_entry["enc_type"]:`none;

		    /////////////////////////////////////////////
		    // entries for table
		    term a = `item(`id(dev_fstab));
		    a = add( a, dev_fstab );
		    a = add( a, mount_fstab );
		    if( mount_fstab=="/" )
			{
			table_input["root"] = dev_fstab;
			}
		    table_input["tbl"] = add( table_input["tbl"]:[], a );
		    }
		});
	    new_partitions = add( new_partitions, new_partition);
	    });
	target["partitions"] = new_partitions;
	new_targetMap[dev] = target;
	});

    y2milestone( "AddFstabToData table_input %1", table_input );
    y2milestone( "AddFstabToData tbl %1", table_input["tbl"]:[] );

    if( size( table_input["tbl"]:[] )>1 )
	{
	table_input["tbl"] = sort( term a, term b, table_input["tbl"]:[],
	                           ``(a[2]:""<b[2]:""));
	}
    y2milestone( "AddFstabToData ret %1", [ new_targetMap, table_input ] );

    return [ new_targetMap, table_input ];
    };


define boolean CheckResizePossible( boolean ask, boolean lvm, integer resize,
                                    symbol fsys, string mount )
    ``{
    map poss = FileSystems::IsResizable( fsys );
    boolean ret = true;

    y2milestone( "CheckResizePossible resize %1 ask %2 lvm %3 fsys %4 mount %5",
                 resize, ask, lvm, fsys, mount );
    if( size(mount)>0 && !Stage::initial() && resize < 0 &&
        !poss["mount_shrink"]:false && poss["shrink"]:false )
        {
	FsysCannotResizeMountPopup( lvm, mount );
	ret = false;
	}
    else if( size(mount)>0 && !Stage::initial() && resize > 0 &&
             !poss["mount_extend"]:false && poss["extend"]:false )
        {
	FsysCannotResizeMountPopup( lvm, mount );
	ret = false;
	}
    else if( size(mount)>0 && !Stage::initial() && resize != 0 && !lvm )
        {
	FsysCannotResizeMountPopup( lvm, mount );
	ret = false;
	}
    else if( resize < 0 && !poss["shrink"]:false )
	{
	ret = FsysCannotShrinkPopup( ask, lvm );
	}
    else if( resize < 0 && fsys==`reiser )
	{
	ret = FsysShrinkReiserWarning( lvm );
	}
    else if( resize>0 && !poss["extend"]:false )
	{
	ret = FsysCannotGrowPopup( ask, lvm );
	}
    y2milestone( "ret %1", ret );
    return( ret );
    }


}
