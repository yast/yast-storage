/**
 * File:	ep-hd-dialogs.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";


    string MiniWorkflowStepPartitionTypeHelptext()
    {
	// helptext
	string helptext = _("<p>Choose the partition type for the new partition.</p>");

	return helptext;
    }


    symbol MiniWorkflowStepPartitionType(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepPartitionType data:%1", data);

	symbol type = data["type"]:`unknown;
	map slots = data["slots"]:$[];

	term tmp = `VBox();

	if (haskey(slots, `primary))
	    // radio button text
	    tmp = add(tmp, `LeftRadioButton(`id(`primary), _("&Primary Partition"), type == `primary));

	if (haskey(slots, `extended))
	    // radio button text
	    tmp = add(tmp, `LeftRadioButton(`id(`extended), _("&Extended Partition"), type == `extended));

	if (haskey(slots, `logical))
	    // radio button text
	    tmp = add(tmp, `LeftRadioButton(`id(`logical), _("&Logical Partition"), type == `logical));

	// heading for a frame in a dialog
	term contents = `HVSquash(
			    `FrameWithMarginBox(_("New Partition Type"),
				`RadioButtonGroup(`id(`partition_type), tmp)));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepPartitionTypeHelptext());
	MiniWorkflow::SetLastStep(false);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    switch (widget)
	    {
		case `next:
		    type = (symbol) UI::QueryWidget(`id(`partition_type), `Value);
		    break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    data["type"] = type;

	    map r = Storage::NextPartition(data["disk_device"]:"", data["type"]:`none);
	    data["device"] = r["device"]:"";

	    if (data["type"]:`unknown == `extended)
	    {
		data["fsid"] = Partitions::fsid_extended_win;
		data["used_fs"] = `unknown;
	    }
	}

	y2milestone("MiniWorkflowStepPartitionType data:%1 ret:%2", data, widget);

	return widget;
    }


    string MiniWorkflowStepPartitionSizeHelptext()
    {
	// helptext
	string helptext = _("<p>Choose the size for the new partition.</p>");

	return helptext;
    }


    symbol MiniWorkflowStepPartitionSize(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepPartitionSize data:%1", data);

	integer cyl_size = data["cyl_size"]:0;
	integer cyl_count = data["cyl_count"]:0;
	list< list<integer> > slots = data["slots", data["type"]:`unknown]:[];
	list<integer> slot = slots[0]:[];

	list<integer> region = data["region"]:slot;
	integer size_k = (region[1]:0 * cyl_size) / 1024;

	integer min_num_cyl = 0;
	integer max_num_cyl = slot[1]:0;

	integer min_size_k = tointeger(min_num_cyl * cyl_size / 1024.0);
	integer max_size_k = tointeger(max_num_cyl * cyl_size / 1024.0);

	symbol type = data["type"]:`unknown;
	symbol what = `nothing; // ;-)

	//prefer max size for extended partition (#428337)
	//cascaded triple operators would do, but this is more readable
	if (region == slot)
        {
	   what = (type == `extended) ? `max_size: `manual_size;
	}
	else
	{
	    what = `manual_region;
	}

	term contents = `HVSquash(
	    // frame heading
	    `FrameWithMarginBox(_("New Partition Size"),
		   `RadioButtonGroup(`id(`size),
				     `VBox(
					 `LeftRadioButton(`id(`max_size), `opt(`notify),
							  // radio button text, %1 is replaced by size
							  sformat(_("Maximum Size (%1)"), Storage::KByteToHumanString(max_size_k))),
					 // radio button text
					 `LeftRadioButtonWithAttachment(`id(`manual_size), `opt(`notify), _("Custom Size"),
									`VBox(`id(`manual_size_attachment),
									      `MinWidth(15, `InputField(`id(`size_input),
													`opt(`shrinkable), _("Size")))
									    )),
					 // radio button text
					 `LeftRadioButtonWithAttachment(`id(`manual_region), `opt(`notify), _("Custom Region"),
									`VBox(`id(`manual_region_attachment),
									      `MinWidth(10, `IntField(`id(`start_cyl), _("Start Cylinder"),
												      0, cyl_count, Region::Start(region))),
									      `MinWidth(10, `IntField(`id(`end_cyl), _("End Cylinder"),
												      0, cyl_count, Region::End(region)))
									    ))
					 )
				)
		       ));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepPartitionSizeHelptext());
	MiniWorkflow::SetLastStep( type == `extended);

	UI::ChangeWidget(`id(`size), `Value, what);
	UI::SetFocus( (what == `extended) ? `id(`max_size) : ( what == `manual_size ? `id(`size_input) : `id(`manual_region)) );
	UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, what == `manual_size);
	UI::ChangeWidget(`id(`size_input), `Value, Storage::KByteToHumanString(size_k));
	UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, what == `manual_region);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    switch (widget)
	    {
		case `max_size:
		    UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, false);
		    UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, false);
		    break;

		case `manual_size:
		    UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, true);
		    UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, false);
		    UI::SetFocus(`id(`size_input));
		    break;

		case `manual_region:
		    UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, false);
		    UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, true);
		    UI::SetFocus(`id(`end_cyl)); // or `start_cyl, who cares
		    break;

		case `next:
		    what = (symbol) UI::QueryWidget(`id(`size), `Value);

		    switch (what)
		    {
			case `manual_size:
			{
			    string tmp = (string) UI::QueryWidget(`id(`size_input), `Value);
			    if (!Storage::HumanStringToKByteWithRangeCheck(tmp, size_k, min_size_k, max_size_k))
			    {
				// error popup, %1 and %2 are replaced by sizes
				Popup::Error(sformat(_("The size entered is invalid. Enter a size between %1 and %2."),
						     Storage::KByteToHumanString(min_size_k),
						     Storage::KByteToHumanString(max_size_k)));
				UI::SetFocus(`id(`size_input));
				widget = `again;
				continue;
			    }
			    break;
			}

			case `manual_region:
			{
			    integer s = (integer) UI::QueryWidget(`id(`start_cyl), `Value);
			    integer e = (integer) UI::QueryWidget(`id(`end_cyl), `Value);
			    region = [ s, e - s + 1 ];

			    boolean valid = Region::Length(region) > 0 && find(list<integer> slot, slots, {
				return Region::Inside(slot, region);
			    }) != nil;

			    if (!valid)
			    {
				// error popup
				Popup::Error(_("The region entered is invalid."));
				UI::SetFocus(`id(`end_cyl));
				widget = `again;
				continue;
			    }

			    break;
			}
		    }

		    break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    switch ((symbol) UI::QueryWidget(`id(`size), `Value))
	    {
		case `max_size:
		{
		    data["region"] = slot;
		    break;
		}

		case `manual_size:
		{
		    integer num_cyl = tointeger(1024.0 * size_k / cyl_size + 0.5);
		    num_cyl = Integer::Clamp(num_cyl, min_num_cyl, max_num_cyl);
		    data["region"] = [ slot[0]:0, num_cyl ];
		    break;
		}

		case `manual_region:
		{
		    data["region"] = region;
		    break;
		}
	    }

	    data["size_k"] = Region::Length(data["region"]:[0, 0]) * cyl_size / 1024;

	    if (data["type"]:`unknown == `extended)
	    {
		widget = `finish;
	    }
	}

	y2milestone("MiniWorkflowStepPartitionSize data:%1 ret:%2", data, widget);

	return widget;
    }


    boolean DlgCreatePartition(map<string, any> &data)
    {
	map<string, any> aliases = $[
	    "Type"        : ``(MiniWorkflowStepPartitionType(data)),
	    "Size"        : ``(MiniWorkflowStepPartitionSize(data)),
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "Type"        : $[ `next : "Size" ],
	    "Size"        : $[ `next : "FormatMount",
			       `finish : `finish ],
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	map slots = data["slots"]:$[];

	if (haskey(slots, `primary))
	    data["type"] = `primary;
	else if (haskey(slots, `extended))
	    data["type"] = `extended;
	else if (haskey(slots, `logical))
	    data["type"] = `logical;

	string start = size(slots) == 1 ? "Size" : "Type";

	if (start == "Size")
	{
	    map r = Storage::NextPartition(data["disk_device"]:"", data["type"]:`none);
	    data["device"] = r["device"]:"";
	}

	// dialog title
	string title = sformat(_("Add Partition on %1"), data["disk_device"]:"error");

	symbol widget = MiniWorkflow::Run(title, StorageIcons::hd_part_icon, aliases, sequence, start);

	return widget == `finish;
    }


    boolean DlgEditPartition(map<string, any> &data)
    {
	string device = data["device"]:"error";

	map<string, any> aliases = $[
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	// dialog title
	string title = sformat(_("Edit Partition %1"), device);

	symbol widget = MiniWorkflow::Run(title, StorageIcons::hd_part_icon, aliases, sequence, "FormatMount");

	return widget == `finish;
    }


    boolean DlgResizePartition(map<string, any> &data, map <string, any> disk)
    {
	return DlgResize(data, disk);
    }

    boolean ConfirmPartitionsDelete( string disk, list<string> pnames )
    {
	return ConfirmRecursiveDelete( disk, pnames,
	     _("Confirm Deleting of All Partitions"),
	    sformat(_("The disk \"%1\" contains at least one partition.
If you proceed, the following partitions will be deleted:"), disk),
	    sformat(_("Really delete all partitions on \"%1\"?"), disk)
	);
    }
}
