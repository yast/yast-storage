/**
 * Module: 		Storage.ycp
 *
 * Authors:		Johannes Buchhold (jbuch@suse.de)
 *
 * Purpose: 		These module contains all settings/information which
 * are needed to partitioning the harddisk. Futhermore it contains a interface
 * to * access and modify the partitioning settings.
 *
 * Todo: Translate
 * Diese Modul enthält alle Informationen die für die Partitionierung der
 * Festplatten erforderlich sind. Diese Informationen bestehen aus der
 * Beschreibung, der vor der Partitionierung vorhandenen Platteneinstellungen,
 * und der Art und Weise wie diese verändert werden soll.
 * Alle nötigen Zugriffsfunktionen auf diese Datenstruktur sind ebenfalls in
 * diesem Modul enthalten. Der Zugriff auf die Speicherung der
 * Partitionseinstellungen läuft also nur über dieses Modul.
 * Der Zugriff und die Rückgabe von Teilen der Partitionsdatenstruktur
 * wurde versucht "intelligent" zu gestallten und ist im einzelen bei den
 * entspechenden Funktionen näher erklärt.
 *
 * $Id$
 */
{

  module "Storage";
  textdomain "storage";

  import "Arch";
  import "AsciiFile";
  import "Encoding";
  import "Directory";
  import "FileSystems";
  import "Installation";
  import "Label";
  import "Mode";
  import "Partitions";
  import "Popup";
  import "Misc";
  import "HTML";
  import "StorageDevices";
  import "StorageClients";
  import "ProductFeatures";
  import "Stage";
  import "String";
  import "Hotplug";

  import "LibStorage";
  import "LibStorage::StorageInterface";
  import "LibStorage::VolumeInfo";
  import "LibStorage::PartitionInfo";
  import "LibStorage::LvmLvInfo";
  import "LibStorage::EvmsInfo";
  import "LibStorage::MdInfo";
  import "LibStorage::LoopInfo";
  import "LibStorage::DmInfo";
  import "LibStorage::NfsInfo";
  import "LibStorage::ContainerInfo";
  import "LibStorage::DiskInfo";
  import "LibStorage::LvmVgInfo";
  import "LibStorage::EvmsCoInfo";

map<string,any> conv_ctype =
    $[ "def_sym" : `CT_UNKNOWN,
       "def_int" : LibStorage::CUNKNOWN(),
       "m" : $[ LibStorage::DISK() : `CT_DISK,
                LibStorage::MD() : `CT_MD,
                LibStorage::LOOP() : `CT_LOOP,
                LibStorage::LVM() : `CT_LVM,
                LibStorage::EVMS() : `CT_EVMS,
                LibStorage::DM() : `CT_DM,
		LibStorage::NFSC() : `CT_NFS
	      ]
     ];

map<string,any> conv_usedby =
    $[ "def_sym" : `UB_NONE,
       "def_int" : LibStorage::UB_NONE(),
       "m" : $[ LibStorage::UB_LVM() : `UB_LVM,
                LibStorage::UB_MD() : `UB_MD,
                LibStorage::UB_EVMS() : `UB_EVMS,
                LibStorage::UB_DM() : `UB_DM
	      ]
     ];

map<string,any> conv_ptype =
    $[ "def_sym" : `primary,
       "def_int" : LibStorage::PRIMARY(),
       "m" : $[ LibStorage::LOGICAL() : `logical,
                LibStorage::EXTENDED() : `extended
	      ]
     ];

map<string,any> conv_mountby =
    $[ "def_sym" : `device,
       "def_int" : LibStorage::MOUNTBY_DEVICE(),
       "m" : $[ LibStorage::MOUNTBY_UUID() : `uuid,
                LibStorage::MOUNTBY_LABEL() : `label,
		LibStorage::MOUNTBY_ID() : `id,
		LibStorage::MOUNTBY_PATH() : `path
	      ]
     ];

map<string,any> conv_encryption =
    $[ "def_sym" : `none,
       "def_int" : LibStorage::ENC_NONE(),
       "m" : $[ LibStorage::ENC_TWOFISH() : `twofish,
                LibStorage::ENC_TWOFISH_OLD() : `twofish_old,
                LibStorage::ENC_TWOFISH256_OLD() : `twofish_256_old,
                LibStorage::ENC_LUKS() : `luks,
                LibStorage::ENC_UNKNOWN() : `unknown,
	      ]
     ];

map<string,any> conv_mdtype =
    $[ "def_sym" : `raid_unknown,
       "def_int" : LibStorage::RAID_UNK(),
       "m" : $[ LibStorage::RAID0() : `raid0,
                LibStorage::RAID1() : `raid1,
                LibStorage::RAID5() : `raid5,
                LibStorage::RAID6() : `raid6,
                LibStorage::RAID10() : `raid10,
                LibStorage::MULTIPATH() : `multipath
	      ]
     ];

map<string,integer> conv_mdstring =
    $[ "raid0" : LibStorage::RAID0(),
       "raid1" : LibStorage::RAID1(),
       "raid5" : LibStorage::RAID5(),
       "raid6" : LibStorage::RAID6(),
       "raid10" : LibStorage::RAID10(),
       "multipath" : LibStorage::MULTIPATH() ];

map<string,any> conv_mdparity =
    $[ "def_sym" : `par_none,
       "def_int" : LibStorage::PAR_NONE(),
       "m" : $[ LibStorage::LEFT_ASYMMETRIC() : `left_asymmetric,
                LibStorage::LEFT_SYMMETRIC() : `left_symmetric,
                LibStorage::RIGHT_ASYMMETRIC() : `right_asymmetric,
                LibStorage::RIGHT_SYMMETRIC() : `right_symmetric
	      ]
     ];

map<string,integer> conv_parstring =
    $[ "left_asymmetric" : LibStorage::LEFT_ASYMMETRIC(),
       "left_symmetric" : LibStorage::LEFT_SYMMETRIC(),
       "right_asymmetric" : LibStorage::RIGHT_ASYMMETRIC(),
       "right_symmetric" : LibStorage::RIGHT_SYMMETRIC() ];

global boolean DoCheckEvmsNonEvms = true;
global boolean DoCheckEvmsLvm = true;
map DiskMapVersion = $[];
map DiskMap = $[];
map ClassifiedSettings = $[];
map type_order = $[ `CT_DISK : 0, `CT_MD : 1, `CT_LOOP : 2, `CT_DM : 3,
                    `CT_LVM : 4, `CT_EVMS : 5, `CT_NFS : 6 ];
list<string> hw_packages = [];
list<string> no_propose_disks = nil;
boolean proposal_evms = false;
boolean proposal_lvm = false;
boolean proposal_home = false;
map cfg_xml = $[];


 /*
  include "storage/routines.ycp";
 */
  /**
   * Get Device Name
   * @param disk Disk
   * @param any partition
   * @return string device name
   */
global define string GetDeviceName( string disk, any partition )
    {
      string ret = disk;

      if( is( partition, integer ) )
	  {
  	  if( search( disk, "/dev/cciss/" )==0 ||
  	      search( disk, "/dev/ida/" )==0 ||
  	      search( disk, "/dev/ataraid/" )==0 ||
  	      search( disk, "/dev/etherd/" )==0 ||
  	      search( disk, "/dev/rd/" )==0 )
  	      {
  	      ret = ret + "p";
  	      }
  	  ret = ret + sformat( "%1", partition );
	  }
      else if( size( (string)partition )>0 )
          {
  	  ret = ret + "/" + (string)partition;
	  }
      return( ret );
  };

global string EvmsDevDisk( string dev )
    {
    string ret = "/dev/" + substring( dev, 10 );
    integer pos = search( ret, "!" );
    y2milestone( "EvmsDevDisk pos:%1", pos );
    if( pos!=nil )
	ret = String::Replace( ret, "!", "/" );
    pos = search( ret, "|" );
    y2milestone( "EvmsDevDisk pos:%1", pos );
    if( pos!=nil )
	ret = String::Replace( ret, "|", "/" );
    return( ret );
    }


    /* Storage = TargetMap
    /* Storage = $[ "targets" 			: $[],
		    "lvm_view_all_mnt"    	: true,
		    "whole_disk"    		: false,
		    "must_reread_partitions"   	: false,
		    "win_device"   		: false,
		    "raidtab_created"   	: false,
		    "use_lvm"   		: false,
		    "testsuite"   		: false,
		    "do_resize"    		: "",
		    "part_proposal_mode"        : "",
		    "part_proposal_first"       : true,
		    "focus"		       	: key
		    ]
    */

    global boolean ZeroNewPartitions = false;

    map  StorageMap	= $[];
    map<integer,map>  StorageMaps	= $[];

    /* stringkeys for access  to the Storage map */
    string lvm_view_all_mnt_key  	= "lvm_view_all_mnt";
    string targets_key 			= "targets";
    string targets_backup_key 		= "targets_backup";
    string targets_backup_l_key 	= "targets_l_backup";
    string targets_backup_m_key 	= "targets_m_backup";
    string part_mode_key 		= "part_mode";
    string part_disk_key  		= "part_disk";
    string whole_disk_key 		= "whole_disk";
    string raidtab_created_key 		= "raidtab_created";
    string testsuite_key       		= "testsuite";
    string do_resize_key 		= "do_resize";
    string win_device_key	 	= "win_device";
    string custom_display_key	 	= "custom_display";
    string part_proposal_mode_key	= "part_proposal_mode";
    string part_proposal_first_key	= "part_proposal_first";
    string part_proposal_active_key	= "part_proposal_active";
    string use_lvm_key			= "use_lvm";

    string storage_map_key		= "storage_map";
    string storage_type_key     	= "storage_type";
    string storage_doc_key		= "storage_doc";
    symbol record_key			= `record;
    symbol custom_key			= `custom;
    boolean probe_done             	= false;
    symbol  exit_key               	= `next;
    string  last_used              	= "";
    any sint                            = nil;
    list<map> conts                     = [];

define any createInterface()
    {
    any ret = LibStorage::createStorageInterface(false, false, true);
    if( ZeroNewPartitions )
	LibStorage::StorageInterface::setZeroNewPartitions(ret,true);

    return( ret );
    }

list<map> getContainers();

global define void InitLibstorage()
    {
    if( sint==nil )
	{
	y2milestone( "InitLibstorage" );
	LibStorage::initDefaultLogger();
	sint = createInterface();
	if( Stage::initial() )
	    {
	    LibStorage::StorageInterface::setDetectMountedVolumes(sint,false);
	    LibStorage::StorageInterface::setRootPrefix( sint,
							 Installation::destdir );
	    }

	LibStorage::StorageInterface::setEfiBoot(sint, Partitions::EfiBoot());

	conts = getContainers();
	y2milestone( "InitLibstorage conts:%1", conts );
	FileSystems::InitSlib( sint );
	}
    }

global define map<string,map> GetTargetMap();
/**
*
*/
define map GetDiskPartitionTg( string device, map<string,map> tg )
    ``{
    map ret = $[];
    integer dlen = 0;
    boolean as_string = false;
    list<string> ls = filter( string s, splitstring( device, "/" ), 
                              ``(size(s)>0));
    if( search( device, "LABEL=" )==0 ||
        search( device, "UUID=" )==0 )
	{
	list<string> tl = splitstring( device, "=" );
	ls = [ "dev", "disk", "", tl[1]:"" ];
	ls[2] = (search( device, "LABEL=" )==0)?"by-label":"by-uuid";
	y2milestone( "GetDiskPartitionTg ls:%1", ls );
	}
    y2debug( "GetDiskPartitionTg size:%1 ls:%2", size(ls), ls );

    if( size(ls)>=4 && ls[1]:"" == "disk" &&
        contains( [ "by-id", "by-path", "by-uuid", "by-label" ], ls[2]:"" ))
	{
	map part = $[];
	string regex = "-part[0-9]+$";
	if( ls[2]:"" == "by-label" )
	    {
	    foreach( string dev, map disk, tg, 
		``{
		if( size(ret["disk"]:"")==0 )
		    {
		    part = find( map p, disk["partitions"]:[], 
				 ``(p["label"]:""==ls[3]:""));
		    if( part!=nil )
			{
			ret["disk"] = dev;
			if( haskey( part, "nr" ))
			    ret["nr"] = part["nr"]:(any)0;
			else
			    ret["nr"] = part["name"]:"";
			}
		    }
		});
	    }
	else if( ls[2]:"" == "by-uuid" )
	    {
	    foreach( string dev, map disk, tg, 
		``{
		if( size(ret["disk"]:"")==0 )
		    {
		    part = find( map p, disk["partitions"]:[], 
				 ``(p["uuid"]:""==ls[3]:""));
		    if( part!=nil )
			{
			ret["disk"] = dev;
			if( haskey( part, "nr" ))
			    ret["nr"] = part["nr"]:(any)0;
			else
			    ret["nr"] = part["name"]:"";
			}
		    }
		});
	    }
	else if( ls[2]:"" == "by-id" )
	    {
	    string id = ls[3]:"";
	    integer num = 0;
	    list l = regexppos( id, regex );
	    if( size(l)>0 )
		{
		num = tointeger( substring( id, l[0]:0+5 ));
		id = substring( id, 0, l[0]:0 );
		y2debug( "GetDiskPartitionTg id:%1 num:%2", id, num );
		}
	    foreach( string dev, map disk, tg, 
		``{
		if( size(ret["disk"]:"")==0 &&
		    find( string s, disk["udev_id"]:[], ``(s==id))!=nil)
		    {
		    part = find( map p, disk["partitions"]:[], 
				 ``(p["nr"]:0==num));
		    if( num==0 || part!=nil )
			{
			ret["disk"] = dev;
			if( num>0 )
			    ret["nr"] = num;
			else
			    ret["nr"] = "";
			}
		    }
		});
	    }
	else if( ls[2]:"" == "by-path" )
	    {
	    string id = ls[3]:"";
	    integer num = 0;
	    list l = regexppos( id, regex );
	    if( size(l)>0 )
		{
		num = tointeger( substring( id, l[0]:0+5 ));
		id = substring( id, 0, l[0]:0 );
		y2debug( "GetDiskPartitionTg id:%1 num:%2", id, num );
		}
	    foreach( string dev, map disk, tg, 
		``{
		if( size(ret["disk"]:"")==0 && disk["udev_path"]:"" == id )
		    {
		    part = find( map p, disk["partitions"]:[], 
				 ``(p["nr"]:0==num));
		    if( num==0 || part!=nil )
			{
			ret["disk"] = dev;
			if( num>0 )
			    ret["nr"] = num;
			else
			    ret["nr"] = "";
			}
		    }
		});
	    }
	}
    else if( search( device, "/" )==0 )
	{
	if( search( device, "/dev/hd" )==0 ||
	    search( device, "/dev/sd" )==0 ||
	    search( device, "/dev/ed" )==0 ||
	    search( device, "/dev/iseries/vd" )==0 )
	    {
	    dlen = findfirstof( device, "0123456789" );
	    if( dlen == nil )
		{
		dlen = size(device);
		}
	    }
	else if( search( device, "/dev/md" )==0 && size(ls)==2 )
	    {
	    dlen = 7;
	    }
	else if( search( device, "/dev/loop" )==0 )
	    {
	    dlen = 9;
	    }
	else if( search( device, "/dev/i2o/hd" )==0 )
	    {
	    dlen = 12;
	    }
	else if( search( device, "/dev/rd/" )==0 ||
		 search( device, "/dev/cciss/" )==0 ||
		 search( device, "/dev/ataraid/" )==0 ||
		 search( device, "/dev/etherd/" )==0 ||
		 search( device, "/dev/ida/" )==0 )
	    {
	    integer pos = findlastof( device, "p" );
	    dlen = size(device);
	    if( pos!=nil )
		{
		dlen = pos;
		}
	    }
	else if( search( device, "/dev/dasd" )==0 )
	    {
	    dlen = size(device);
	    if( findfirstof( device, "0123456789" )!=nil )
		{
		dlen = dlen-1;
		}
	    }
	else
	    {
	    as_string = true;
	    if( size(ls)>=3 )
		{
		integer pos = findlastof( device, "/" );
		if( pos!=nil )
		    {
		    dlen = pos;
		    }
		}
	    else
		{
		dlen = size(device);
		integer nonzero = findlastnotof( device, "0123456789" );
		if( nonzero!=nil && nonzero < dlen-1 )
		    {
		    dlen = nonzero+1;
		    as_string = false;
		    }
		}
	    }
	ret = add( ret, "disk", substring( device, 0, dlen ) );
	device = substring( device, dlen );
	if( size(device)>0 && findfirstof( device, "/p" )==0 )
	    {
	    device = substring( device, 1 );
	    }
	ret["nr"] = -1;
	if( as_string )
	    {
	    ret["nr"] = device;
	    }
	else
	    {
	    if( size(device)>0 )
		{
		ret["nr"] = tointeger(device);
		}
	    }
	if( size(ret["disk"]:"")>0 && ret["nr"]:(any)1 == -1 )
	    {
	    ret["nr"] = "";
	    }
	}
    else
	{
	ret = $[ "disk" : "/dev/nfs", "nr" : device ];
	}
    y2debug( "GetDiskPartitionTg device:%1 ret:%2", device, ret );
    return( ret );
    };

global define map GetDiskPartition( string device )
    ``{
    return( GetDiskPartitionTg( device, GetTargetMap() ));
    }

global void UpdateChangeTime()
    {
    integer change_time = time();
    y2milestone( "UpdateChangeTime time %1", change_time );
    StorageMap["targets_time"] = change_time;
    }

/* return partition <device> of map <tg> */
global define map<string,any> GetPartition( map<string,map> tg, string device )
    ``{
    map ret = $[];
    map tmp = GetDiskPartitionTg( device, tg );
    string disk = tmp["disk"]:"";
    if( search(device, "/dev/evms")==0 && !haskey( tg, disk ) )
	{
	disk = "/dev/evms";
	}
    y2debug( "GetPartition device=%1 disk=%2", device, disk );
    list<map> part = filter( map p, tg[disk,"partitions"]:[],
			     ``(p["device"]:""==device ));
    part = filter( map p, part, ``(!p["delete"]:false));
    if( size(part)==0 )
	{
	part = filter( map p, tg[disk,"partitions"]:[],
		       ``(p["nr"]:-1==tmp["nr"]:0 ));
	part = filter( map p, part, ``(!p["delete"]:false));
	}
    if( size(part)==0 )
	{
	part = filter( map p, tg[disk,"partitions"]:[],
		       ``(p["name"]:""==tmp["nr"]:"" ));
	part = filter( map p, part, ``(!p["delete"]:false));
	}
    ret = part[0]:$[];
    if( size(ret)==0 && search(device, "/dev/mapper/")==0 )
	{
	part = filter( map p, tg["/dev/loop","partitions"]:[],
		       ``(p["device"]:""==device ));
	ret = part[0]:$[];
	}
    y2debug( "GetPartition ret=%1", ret );
    return( (map<string,any>) ret );
    }

/* return disk <device> belongs to in map <tg> */
global define map<string,any> GetDisk( map<string,map> tg, string device )
    ``{
    map<string,any> ret = $[];
    map tmp = GetDiskPartitionTg( device, tg );
    string disk = tmp["disk"]:"";
    if( search(device, "/dev/evms")==0 && !haskey( tg, disk ) )
	{
	disk = "/dev/evms";
	}
    y2debug( "GetDisk disk=%1", disk );
    return( (map<string,any>)tg[disk]:$[] );
    }


/* set <part>, return changed map <tg> */
global define map<string,map> SetPartition( map<string,map> tg, map part )
    ``{
    y2milestone( "SetPartition part=%1", part );
    map tmp = GetDiskPartitionTg( part["device"]:"", tg );
    y2milestone( "SetPartition tmp=%1", tmp );
    string disk = tmp["disk"]:"";
    if( search(part["device"]:"", "/dev/evms")==0 && !haskey( tg, disk ) )
	{
	disk = "/dev/evms";
	}
    list r_part = filter(map p, tg[disk,"partitions"]:[],
			  ``(p["device"]:"" != part["device"]:""));
    r_part = add( r_part, part );
    tg[disk,"partitions"] = r_part;
    return( tg );
    }

/**
 * Find next free loop device.
 * @return string loop_dev ( e.g.: /dev/loop1 )
 */
global define string GetLoopDev( integer start )
    ``{
    if( Mode::test () )
	return "/dev/loop2";

    integer max_loop_dev= 15;
    integer loop_dev_nb = start;
    boolean found_free  = false;
    string  loop_dev    = "";

    while( !found_free && loop_dev_nb <= max_loop_dev )
	{
	loop_dev = sformat("/dev/loop%1", loop_dev_nb );
	loop_dev_nb = loop_dev_nb + 1;

	// Test loop dev
	if( SCR::Execute(.target.bash , "/sbin/losetup 2>/dev/null " + loop_dev ) != 0 )
	    found_free = true;
	}

    if( !found_free )
	{
	loop_dev = "";
	// internal error popup
	Popup::Error( _("Too many loop devices (cryptofs ...)") );
	y2error( "Too many loop devices");
	}

    y2milestone("ret \"%1\"",loop_dev);

    return( loop_dev );
    };


/**
 * Get List of swap partitions
 * @return list List of swap partitions
 */
global define list SwappingPartitions()``{
    list ret = [];
    SCR::UnmountAgent (.proc.swaps);
    list<map> swaps = filter(map e, (list<map>) SCR::Read( .proc.swaps ),
                         ``(e["type"]:""=="partition"));
    ret = maplist(map e, swaps, ``(Partitions::TranslateMapperName(e["file"]:"")) );
    y2milestone( "SwappingPartitions %1", ret );
    return( ret );
    }

global define list GetDestroyedLvmVgs( map<string,map> target )
    ``{
    list vgs = [];
    foreach(string diskdev, map disk, target,
	``{
	foreach( map p, disk["partitions"]:[],
	    ``{
	    if( p["used_by_type"]:`UB_NONE==`UB_LVM && p["format"]:false )
		{
		vgs = union( vgs, [ p["used_by"]:"" ] );
		}
	    });
	});
    vgs = sort( vgs );
    y2milestone( "GetDestroyedLvmVgs %1", vgs );
    return( vgs );
    }

global define map<string,map> DeleteDestroyedLvmVgs( map<string,map> target )
    ``{
    list<string> vgs = maplist( string s, (list<string>)GetDestroyedLvmVgs( target ),
				``("/dev/"+s));
    y2milestone( "DeleteDestroyedLvmVgs %1", vgs );
    foreach( string dev, vgs,
	``{
	if( haskey( target, dev ))
	    target[dev,"delete"] = true;
	target[dev,"partitions"] = maplist( map p, target[dev,"partitions"]:[],
					    ``{
					    if( haskey( p, "mount" ))
						p = remove( p, "mount" );
					    return( p );
					    });
	y2milestone( "DeleteDestroyedLvmVgs %1: %2", dev, target[dev]:$[] );
	});
    return( target );
    }

global define map GetFreeSpace( string device, integer testsize,
                                symbol used_fs, boolean verbose )
    ``{
    if( Mode::test() )
	{
	integer wf =  tointeger(tofloat(testsize) * 0.6);
	integer wu =  tointeger(tofloat(testsize) * 0.4);
	integer ls =  tointeger(tofloat(testsize) * 0.5);
	return( $[ "free"  : wf, "used"    : wu,
		   "linux_size"  : ls, "new_size": (wu + wf - ls) ] );
	}

    integer used = 0;
    integer resize_free = 0;
    integer df_free = 0;
    boolean win_disk = false;
    boolean efi = false;

    boolean r = false;
    r = LibStorage::StorageInterface::getFreeInfo( sint, device, resize_free,
                                                   df_free, used, win_disk,
						   efi, used_fs==`ntfs );

    resize_free = resize_free * 1024;	// Byte
    df_free = df_free * 1024;	// Byte
    used = used * 1024;	// Byte

    if( used_fs == `ntfs && !r && verbose )
	{
	string cmd = sformat("ntfsresize -f -i %1", device );
	y2milestone( "GetFreeSpace Executing cmd:%1", cmd );
	map bcall = (map) SCR::Execute( .target.bash_output, cmd,
					$[ "LC_MESSAGES" :"POSIX"] );
	y2milestone( "GetFreeSpace Executing ret:%1", bcall );
	string tmp = _("Resize Not Possible:") + "\n\n";
	tmp = tmp + bcall["stdout"]:"" + bcall["stderr"]:"";
	Popup::Error( tmp );
	return( $[] );
	}

    integer linux_size = 0;
    integer min_linux_size = 0;
    integer add_free = df_free - resize_free;

    y2milestone( "GetFreeSpace resize_free %1 add_free %2", 
                 resize_free, add_free );

    if( resize_free < 300*1024*1024 || !r )
	{
	linux_size = 0;
	min_linux_size = 0;
	}
    else if( resize_free < 600*1024*1024 )
	{
	linux_size = resize_free;
	if( add_free < 75*1024*1024 )
	    {
	    linux_size = linux_size - 75*1024*1024 + add_free;
	    }
	min_linux_size = linux_size;
	}
    else if ( resize_free < 1024*1024*1024 )
	{
	linux_size = resize_free;
	if( add_free < 200*1024*1024 )
	    {
	    linux_size = linux_size - 200*1024*1024 + add_free;
	    }
	min_linux_size = 300*1024*1024;
	}
    else if ( resize_free < 2*1024*1024*1024 )
	{
	linux_size = resize_free;
	if( add_free < 300*1024*1024 )
	    {
	    linux_size = linux_size - 300*1024*1024 + add_free;
	    }
	min_linux_size = 500*1024*1024;
	}
    else if ( resize_free < 3*1024*1024*1024 )
	{
	linux_size = resize_free;
	if( add_free < 800*1024*1024 )
	    {
	    linux_size = linux_size - 800*1024*1024 + add_free;
	    }
	min_linux_size = 500*1024*1024;
	}
    else
	{
	linux_size = resize_free;
	if( add_free < resize_free/3 )
	    {
	    linux_size = linux_size - resize_free/3 + add_free;
	    }
	min_linux_size = 500*1024*1024;
	}

    integer new_size = used + add_free + resize_free - linux_size;

    map ret = $[ "free": (resize_free>0?resize_free:0),
		 "df_free" : df_free,
		 "used":used,
		 "win_disk":win_disk,
		 "efi":efi,
		 "linux_size":linux_size,
		 "max_win_size":used + resize_free + add_free - min_linux_size,
		 "ntfs" : (used_fs == `ntfs),
		 "new_size":new_size ];
    ret["ok"] = r;
    y2milestone( "GetFreeSpace %1 ret %2", device, ret );
    return( ret );
    };

global define map<string,map> AddWinInfo( map<string,map> targets )
    ``{
    y2milestone( "AddWinInfo called" );
    foreach(string disk, map data, targets,
	``{
	targets[disk,"partitions"] =
	    maplist(map p, data["partitions"]:[],
		``{
		if( Partitions::IsDosWinNtPartition(p["fsid"]:0) &&
		    contains( [ `ntfs, `vfat ], p["used_fs"]:`none ))
		    {
		    p["winfo"] = GetFreeSpace( p["device"]:"", 0,
					       p["used_fs"]:`none, false );
		    y2milestone( "AddWinInfo %1", p );
		    }
		return( p );
		});
	});
    return( targets );
    };

global define string SaveDumpPath( string name )``{
    string ret = Directory::tmpdir + "/" + name;
    y2debug( "name=%1 path=%2", name, ret );
    return ret;
    }

//  add mount point for all mounted partitions
global define map<string,map> AddMountPointInfo( map<string,map> target )
    ``{
    list<map> mounts = Partitions::CurMounted();
    foreach(string diskdev, map disk, target,
	``{
	// variable renamed due to some interpreter problems
	list<map> tmp2 = disk["partitions"]:[];
	tmp2 = maplist(map part, tmp2,
	    ``{
	    map mt = find(map mp, mounts, ``(mp["spec"]:" "==part["device"]:"" ||
					   mp["loop_on"]:" "==part["device"]:""));
	    if( mt != nil )
		{
		part["mount"] = mt["file"]:"";
		if( part["noauto"]:false )
		    {
		    part["active"] = true;
		    }
		}
	    return( part );
	    });
	disk["partitions"] = tmp2;
	target[diskdev] = disk;
	});
    return( target );
    }

global define list FindFstabLines( map fstab, string mount, string device,
                                   string uuid, string label )
    ``{
    list<integer> lines = [];
    if( size(mount)>0 && mount != "swap" )
	{
	lines = AsciiFile::FindLineField( fstab, 1, mount );
	}
    if( size(lines)==0 )
	{
	lines = AsciiFile::FindLineField( fstab, 0, device );
	}
    if( size(lines)>1 )
	{
	uuid = "UUID=" + uuid;
	label = "LABEL=" + label;
	map<integer,map> tlines = AsciiFile::GetLines( fstab, lines );
	map<integer,map> nlist = filter(integer num, map line, tlines,
			    ``( line["fields",0]:"" == device ||
				line["fields",0]:"" == uuid ||
				line["fields",0]:"" == label ));
	if( size(nlist)>0 )
	    {
	    lines = maplist( integer num, map line, nlist, ``(num));
	    }
	}
    y2milestone( "lines %1", lines );
    return( lines );
    };

//  add info gotten from /etc/fstab to targetMap
global define map<string,map> AddFstabInfo( map<string,map> target, boolean lineno )
    ``{
    y2milestone( "lineno=%1", lineno );
    map fstab = Partitions::GetFstab( "/etc/fstab" );
    map crtab = Partitions::GetCrypto( "/etc/cryptotab" );
    foreach(string diskdev, map disk, target,
	``{
	list new_part = [];
	foreach(map part, disk["partitions"]:[],
	    ``{
	    list<string> rem = [];
	    if( lineno )
		{
		rem = [ "fstabline", "crtabline" ];
		}
	    else
		{
		rem = [ "mountby", "fstopt" ];
		}
	    part = (map<string,any>)filter(string key, any val, (map<string,any>)part, ``(!contains( rem, key )));
	    string mp = part["mount"]:"";
	    if( size(part["ori_mount"]:"")>0 )
		{
		mp = part["ori_mount"]:"";
		}
	    list lines = [];
	    lines = FindFstabLines( fstab, mp, part["device"]:"",
	                            part["uuid"]:"", part["label"]:"" );
	    if( size(lines)>0 )
		{
		if( lineno )
		    {
		    part["fstabline"] = lines[0]:-1;
		    }
		else
		    {
		    map entry = AsciiFile::GetLine( fstab, lines[0]:-1 );
		    if( entry["fields",3]:"defaults" != "defaults" )
			{
			part["fstopt"] = entry["fields",3]:"";
			}
		    if( search(entry["fields",0]:"", "UUID=") != nil )
			{
			part["mountby"] = `uuid;
			}
		    else if( search(entry["fields",0]:"", "LABEL=") != nil )
			{
			part["mountby"] = `label;
			}
		    else if( search(entry["fields",0]:"", "/dev/disk/by-id/") != nil )
		        {
			part["mountby"] = `id;
			}
		    else if( search(entry["fields",0]:"", "/dev/disk/by-path/") != nil )
		        {
			part["mountby"] = `path;
			}
		    }
		}
	    lines = AsciiFile::FindLineField( crtab, 2, mp );
	    if( size(lines)==0 && diskdev!="/dev/loop" )
		{
		lines = AsciiFile::FindLineField( crtab, 1, part["device"]:"" );
		}
	    if( size(lines)==0 && diskdev=="/dev/loop" )
		{
		lines = AsciiFile::FindLineField( crtab, 0, part["device"]:"" );
		}
	    if( size(lines)>0 )
		{
		if( lineno )
		    {
		    part["crtabline"] = lines[0]:-1;
		    }
		else
		    {
		    map entry = AsciiFile::GetLine( crtab, lines[0]:-1 );
		    if( entry["fields",5]:"defaults" != "defaults" )
			{
			part["fstopt"] = entry["fields",5]:"";
			}
		    }
		}
	    y2milestone( "part=%1", part );
	    new_part = add( new_part, part );
	    });
	target[diskdev] = disk;
	target[diskdev,"partitions"] = new_part;
	});
    return( target );
    }

define string convertFsOptionMapToString( map<any,map> fsopt )
    {
    string ret = "";

    // do nothing
    if( fsopt != nil || fsopt != $[] )
	{
	list ignore = [ "auto", "default", "none", "" ];

	foreach(any option_key, map option, fsopt, 
	    ``{
	    string option_str   = option["option_str"]:"";
	    any    option_value = option["option_value"]:(any)"";
	    boolean option_blank = option["option_blank"]:false;
	    y2milestone( "convertFsOptionMapToString k:%1 opt:%2 val:%3", 
	                 option_key, option, option_value );

	    if( is(option_value, string) && option_value != nil )
		{
		if( !contains( ignore, option_value ))
		    {
		    if( size(ret)>0 )
			ret = ret + " ";
		    ret = ret + option_str;
		    if( option_blank )
			ret = ret + " ";
		    ret = ret + (string)option_value;
		    }
		}
	    else if( is(option_value, boolean) && option_value != nil )
		{
		if( (boolean) option_value )
		    {
		    if( size(ret)>0 )
			ret = ret + " ";
		    ret = ret + option_str;
		    }
		}
	    else if( is(option_value, integer) && option_value != nil )
		{
		if( size(ret)>0 )
		    ret = ret + " ";
		ret = ret + option_str;
		if( option_blank )
		    ret = ret + " ";
		ret = ret + sformat("%1", option_value);
		}
	    });
	}
    if( size(fsopt)>0 || size(ret)>0 )
	y2milestone( "convertFsOptionMapToString fsopt:%1 ret:%2", fsopt, ret );
    return ret;
    };

map convertStringToFsOptionMap( string opts, symbol fs )
    {
    map ret = $[];
    y2milestone( "convertStringToFsOptionMap opts:\"%1\" fs:%2", opts, fs );
    integer pos = findfirstnotof( opts, " \t" );
    if( pos>0 )
	opts = substring( opts, pos );
    list<map> op = (list<map>)FileSystems::GetOptions(fs);
    while( size(opts)>0 )
	{
	boolean found = false;
	foreach( map o, op,
	    ``{
	    map m = $[];
	    string os = o[`option_str]:"";
	    if( !found && size(os)>0 && search( opts, os )==0 )
		{
		found = true;
		m["option_str"] = os;
		if( o[`type]:`text==`boolean )
		    {
		    m["option_value"] = true;
		    ret[o[`query_key]:""] = m;
		    }
		opts = substring( opts, size(os) );
		pos = findfirstnotof( opts, " \t" );
		if( pos>0 )
		    opts = substring( opts, pos );
		if( o[`type]:`text!=`boolean && size(opts)>0 && 
		    search(opts,"-")!=0 )
		    {
		    if( pos>0 )
			m["option_blank"] = true;
		    pos = findfirstof( opts, " \t" );
		    if( pos==nil )
			{
			m["option_value"] = opts;
			opts = "";
			}
		    else
			{
			m["option_value"] = substring( opts, 0, pos );
			opts = substring( opts, pos );
			}
		    ret[o[`query_key]:""] = m;
		    }
		pos = findfirstnotof( opts, " \t" );
		if( pos>0 )
		    opts = substring( opts, pos );
		}
	    });
	if( !found )
	    {
	    pos = findfirstnotof( opts, " \t" );
	    if( pos>0 )
		opts = substring( opts, pos );
	    else
		opts = "";
	    }
	y2milestone( "convertStringToFsOptionMap opts:%1 ret:%2", opts, ret );
	}
    y2milestone( "convertStringToFsOptionMap ret:%1", ret );
    return( ret );
    }

symbol toSymbol( map<string,any> conv, integer val )
    {
    return( conv["m",val]:(conv["def_sym"]:`invalid_conv_map) );
    }

integer fromSymbol( map<string,any> conv, symbol val )
    {
    integer ret = conv["def_int"]:-1;
    foreach( integer i, symbol s, conv["m"]:$[],
	``{
	if( s==val )
	    ret = i;
	});
    return( ret );
    }

global define boolean CheckBackupState( string who )
    {
    y2milestone( "CheckBackupStates who:%1", who );
    InitLibstorage();
    boolean ret = LibStorage::StorageInterface::checkBackupState( sint, who );
    y2milestone( "CheckBackupStates ret:%1", ret );
    return( ret );
    }

map volumeMap( any vinfo, map p )
    {
    p["device"] = LibStorage::VolumeInfo::swig_device_get(vinfo);
    p["size_k"] = LibStorage::VolumeInfo::swig_sizeK_get(vinfo);
    p["name"] = LibStorage::VolumeInfo::swig_name_get(vinfo);
    integer t = LibStorage::VolumeInfo::swig_fs_get(vinfo);
    symbol fs = toSymbol( FileSystems::conv_fs, t );
    p["detected_fs"] = fs;
    if( fs != `unknown )
	p["used_fs"] = fs;
    boolean tbool = LibStorage::VolumeInfo::swig_format_get(vinfo);
    if( tbool )
	p["format"] = true;
    tbool = LibStorage::VolumeInfo::swig_create_get(vinfo);
    if( tbool )
	p["create"] = true;
    string tmp = LibStorage::VolumeInfo::swig_mount_get(vinfo);
    if( size(tmp)>0 )
	{
	p["mount"] = tmp;
	tbool = LibStorage::VolumeInfo::swig_is_mounted_get(vinfo);
	if( !tbool )
	    p["inactive"] = true;
	t = LibStorage::VolumeInfo::swig_mount_by_get(vinfo);
	p["mountby"] = toSymbol( conv_mountby, t );
	}
    t = LibStorage::VolumeInfo::swig_usedBy_get(vinfo);
    if( t!=LibStorage::UB_NONE() )
	{
	p["used_by_type"] = toSymbol( conv_usedby, t );
	p["used_by"] = LibStorage::VolumeInfo::swig_usedByName_get(vinfo);
	}
    tmp = LibStorage::VolumeInfo::swig_fstab_options_get(vinfo);
    if( size(tmp)>0 )
	{
	p["fstopt"] = tmp;
	if( find( string s, splitstring( tmp, "," ), ``(s=="noauto") )!=nil )
	    p["noauto"] = true;
	}
    tmp = LibStorage::VolumeInfo::swig_mkfs_options_get(vinfo);
    if( size(tmp)>0 )
	{
	p["mkfs_opt"] = tmp;
	p["fs_options"] = 
	    convertStringToFsOptionMap( tmp, p["detected_fs"]:`unknown );
	}
    else
	{
	if( haskey( p, "fs_options" ))
	    p = remove( p, "fs_options" );
	}
    tmp = LibStorage::VolumeInfo::swig_dtxt_get(vinfo);
    if( size(tmp)>0 )
	p["dtxt"] = tmp;
    tmp = LibStorage::VolumeInfo::swig_uuid_get(vinfo);
    if( size(tmp)>0 )
	p["uuid"] = tmp;
    tmp = LibStorage::VolumeInfo::swig_label_get(vinfo);
    if( size(tmp)>0 )
	p["label"] = tmp;
    t = LibStorage::VolumeInfo::swig_encryption_get(vinfo);
    if( t!=LibStorage::ENC_NONE() )
	{
	p["enc_type"] = toSymbol( conv_encryption, t );
	}
    tbool = LibStorage::VolumeInfo::swig_resize_get(vinfo);
    if( tbool )
	{
	p["resize"] = true;
	p["orig_size_k"] = LibStorage::VolumeInfo::swig_OrigSizeK_get(vinfo);
	}
    tbool = LibStorage::VolumeInfo::swig_ignore_fs_get(vinfo);
    if( tbool )
	p["ignore_fs"] = true;
    tmp = LibStorage::VolumeInfo::swig_loop_get(vinfo);
    if( size(tmp)>0 )
	p["loop"] = tmp;
    return( p );
    }

map getContainerInfo( map c )
    {
    y2milestone( "getContainerInfo %1", c );
    integer ret = 0;
    integer t = 0;
    any vinfo = LibStorage::VolumeInfo::new("LibStorage::VolumeInfo");
    if( c["type"]:`CT_UNKNOWN == `CT_DISK )
	{
	list<any> pinfos = [];
	any infos = LibStorage::DiskInfo::new("LibStorage::DiskInfo");
	string d = c["device"]:"";
	ret = LibStorage::StorageInterface::getDiskInfo( sint, d, infos );
	if( ret==0 )
	    {
	    c["size_k"] = LibStorage::DiskInfo::swig_sizeK_get(infos);
	    c["cyl_size"] = LibStorage::DiskInfo::swig_cylSizeB_get(infos);
	    c["cyl_count"] = LibStorage::DiskInfo::swig_cyl_get(infos);
	    c["label"] = LibStorage::DiskInfo::swig_disklabel_get(infos);
	    c["max_logical"] = LibStorage::DiskInfo::swig_maxLogical_get(infos);
	    c["max_primary"] = LibStorage::DiskInfo::swig_maxPrimary_get(infos);
	    boolean bt = LibStorage::DiskInfo::swig_iscsi_get(infos);
	    if( bt )
		c["iscsi"] = true;
	    bt = LibStorage::DiskInfo::swig_initDisk_get(infos);
	    if( bt )
		c["dasdfmt"] = true;
	    else if( haskey( c, "dasdfmt" ))
		c = remove( c, "dasdfmt" );
	    string tmp = LibStorage::DiskInfo::swig_udevId_get(infos);
	    if( size(tmp)>0 )
		c["udev_id"] = splitstring( tmp, " " );
	    else if( haskey( c, "udev_id" ))
		c = remove( c, "udev_id" );
	    tmp = LibStorage::DiskInfo::swig_udevPath_get(infos);
	    if( size(tmp)>0 )
		c["udev_path"] = tmp;
	    else if( haskey( c, "udev_path" ))
		c = remove( c, "udev_path" );
	    }
	else
	    y2warning( "disk \"%1\" ret:%2", c["device"]:"", ret );
	c["partitions"] = [];
	ret = LibStorage::StorageInterface::getPartitionInfo( sint, d, pinfos );
	foreach( any info, pinfos,
	    ``{
	    string tmp = "";
	    map p = $[];
	    vinfo = LibStorage::PartitionInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::PartitionInfo::swig_nr_get(info);
	    p["fsid"] = LibStorage::PartitionInfo::swig_id_get(info);
	    p["fstype"] = Partitions::FsIdToString( p["fsid"]:0 );
	    p["region"] = [ LibStorage::PartitionInfo::swig_cylStart_get(info),
			    LibStorage::PartitionInfo::swig_cylSize_get(info) ];
	    t = LibStorage::PartitionInfo::swig_partitionType_get(info);
	    p["type"] = toSymbol( conv_ptype, t );
	    boolean boot = LibStorage::PartitionInfo::swig_boot_get(info);
	    if( boot )
		p["boot"] = true;
	    tmp = LibStorage::PartitionInfo::swig_udevId_get(info);
	    if( size(tmp)>0 )
		p["udev_id"] = splitstring( tmp, " " );
	    tmp = LibStorage::PartitionInfo::swig_udevPath_get(info);
	    if( size(tmp)>0 )
		p["udev_path"] = tmp;
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	pinfos = [];
	ret = LibStorage::StorageInterface::getPartitionInfo( sint, d, pinfos );
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_LVM )
	{
	list<any> pinfos = [];
	any infos = LibStorage::LvmVgInfo::new("LibStorage::LvmVgInfo");
	string n = c["name"]:"";
	ret = LibStorage::StorageInterface::getLvmVgInfo( sint, n, infos );
	if( ret==0 )
	    {
	    c["create"] = LibStorage::LvmVgInfo::swig_create_get(infos);
	    c["size_k"] = LibStorage::LvmVgInfo::swig_sizeK_get(infos);
	    c["cyl_size"] = 1024*LibStorage::LvmVgInfo::swig_peSize_get(infos);
	    c["pesize"] = 1024*LibStorage::LvmVgInfo::swig_peSize_get(infos);
	    c["cyl_count"] = LibStorage::LvmVgInfo::swig_peCount_get(infos);
	    c["pe_free"] = LibStorage::LvmVgInfo::swig_peFree_get(infos);
	    c["lvm2"] = LibStorage::LvmVgInfo::swig_lvm2_get(infos);
	    list<string> ls = splitstring( LibStorage::LvmVgInfo::swig_devices_get(infos), " " );
	    y2milestone( "ls=%1", ls );
	    c["devices"] = ls;
	    ls = splitstring( LibStorage::LvmVgInfo::swig_devices_add_get(infos), " " );
	    if( size(ls)>0 )
		c["devices_add"] = ls;
	    ls = splitstring( LibStorage::LvmVgInfo::swig_devices_rem_get(infos), " " );
	    if( size(ls)>0 )
		c["devices_rem"] = ls;
	    }
	else
	    y2warning( "LVM Vg \"%1\" ret:%2", c["name"]:"", ret );
	ret = LibStorage::StorageInterface::getLvmLvInfo( sint, n, pinfos );
	foreach( any info, pinfos,
	    ``{
	    map p = $[];
	    vinfo = LibStorage::LvmLvInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["stripes"] = LibStorage::LvmLvInfo::swig_stripe_get(info);
	    t = LibStorage::LvmLvInfo::swig_stripe_size_get(info);
	    if( t>0 )
		p["stripesize"] = t;
	    p["type"] = `lvm;
	    p["fstype"] = Partitions::lv_name;
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_EVMS )
	{
	list<any> pinfos = [];
	any infos = LibStorage::EvmsCoInfo::new("LibStorage::EvmsCoInfo");
	string n = c["name"]:"";
	c["is_container"] = size(c["name"]:"")>0;
	if( c["is_container"]:false )
	    {
	    ret = LibStorage::StorageInterface::getEvmsCoInfo( sint, n, infos );
	    if( ret==0 )
		{
		c["create"] = LibStorage::EvmsCoInfo::swig_create_get(infos);
		c["size_k"] = LibStorage::EvmsCoInfo::swig_sizeK_get(infos);
		c["cyl_size"] = 1024*LibStorage::EvmsCoInfo::swig_peSize_get(infos);
		c["pesize"] = 1024*LibStorage::EvmsCoInfo::swig_peSize_get(infos);
		c["cyl_count"] = LibStorage::EvmsCoInfo::swig_peCount_get(infos);
		c["pe_free"] = LibStorage::EvmsCoInfo::swig_peFree_get(infos);
		c["lvm2"] = LibStorage::EvmsCoInfo::swig_lvm2_get(infos);
		list<string> ls = splitstring( LibStorage::EvmsCoInfo::swig_devices_get(infos), " " );
		c["devices"] = ls;
		ls = splitstring( LibStorage::EvmsCoInfo::swig_devices_add_get(infos), " " );
		if( size(ls)>0 )
		    c["devices_add"] = ls;
		ls = splitstring( LibStorage::EvmsCoInfo::swig_devices_rem_get(infos), " " );
		if( size(ls)>0 )
		    c["devices_rem"] = ls;
		}
	    else
		y2warning( "EVMS Co \"%1\" ret:%2", c["name"]:"", ret );
	    }
	ret = LibStorage::StorageInterface::getEvmsInfo( sint, n, pinfos );
	if( ret<0 )
	    y2warning( "getEvmsInfo ret:%1", ret );
	y2milestone( "getContainerInfo n:%1 ret=%2", n, ret );
	foreach( any info, pinfos,
	    ``{
	    map p = $[];
	    vinfo = LibStorage::EvmsInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["stripes"] = LibStorage::EvmsInfo::swig_stripe_get(info);
	    t = LibStorage::EvmsInfo::swig_stripe_size_get(info);
	    if( t>0 )
		p["stripesize"] = t;
	    boolean tbool = LibStorage::EvmsInfo::swig_compatible_get(info);
	    if( !tbool )
		p["evms_native"] = true;
	    p["type"] = `evms;
	    p["fstype"] = Partitions::evms_name;
	    y2milestone( "partition %1", p );
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_MD )
	{
	list<any> pinfos = [];
	ret = LibStorage::StorageInterface::getMdInfo( sint, pinfos );
	if( ret<0 )
	    y2warning( "getMdInfo ret:%1", ret );
	foreach( any info, pinfos,
	    ``{
	    map p = $[];
	    vinfo = LibStorage::MdInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::MdInfo::swig_nr_get(info);
	    y2milestone( "MdInfo p=%1", p );
	    integer t = LibStorage::MdInfo::swig_type_get(info);
	    y2milestone( "MdInfo t=%1", t );
	    p["raid_type"] = substring( sformat( "%1", toSymbol( conv_mdtype, t )), 1 );
	    y2milestone( "MdInfo p=%1", p );
	    if( p["raid_type"]:""=="raid5" )
		{
		t = LibStorage::MdInfo::swig_parity_get(info);
		symbol pt = toSymbol( conv_mdparity, t );
		if( pt != `par_none )
		    p["parity_algorithm"] = substring( sformat( "%1", pt), 1 );
		}
	    y2milestone( "MdInfo p=%1", p );
	    p["type"] = `sw_raid;
	    p["fstype"] = Partitions::raid_name;
	    y2milestone( "MdInfo p=%1", p );
	    t = LibStorage::MdInfo::swig_chunk_get(info);
	    if( t>0 )
		{
		p["chunk_size"] = t;
		}
	    y2milestone( "MdInfo string ls=%1", LibStorage::MdInfo::swig_devices_get(info) );
	    list<string> ls = splitstring( LibStorage::MdInfo::swig_devices_get(info), " " );
	    y2milestone( "MdInfo ls=%1", ls );
	    p["devices"] = ls;
	    y2milestone( "getContainerInfo MdInfo p:%1", p );
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_LOOP )
	{
	list<any> pinfos = [];
	ret = LibStorage::StorageInterface::getLoopInfo( sint, pinfos );
	if( ret<0 )
	    y2warning( "getLoopInfo ret:%1", ret );
	foreach( any info, pinfos,
	    ``{
	    map p = $[];
	    vinfo = LibStorage::LoopInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::LoopInfo::swig_nr_get(info);
	    p["type"] = `loop;
	    p["fstype"] = Partitions::loop_name;
	    p["fpath"] = LibStorage::LoopInfo::swig_file_get(info);
	    p["create_file"] = !LibStorage::LoopInfo::swig_reuseFile_get(info);
	    if( p["enc_type"]:`unknown != `luks )
		p["device"] = p["loop"]:"";
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_DM )
	{
	list<any> pinfos = [];
	ret = LibStorage::StorageInterface::getDmInfo( sint, pinfos );
	if( ret<0 )
	    y2warning( "getDmInfo ret:%1", ret );
	foreach( any info, pinfos,
	    ``{
	    map p = $[];
	    vinfo = LibStorage::DmInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::DmInfo::swig_nr_get(info);
	    p["type"] = `dm;
	    p["fstype"] = Partitions::dm_name;
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_NFS )
	{
	list<any> pinfos = [];
	y2milestone( "before getNfsInfo" );
	ret = LibStorage::StorageInterface::getNfsInfo( sint, pinfos );
	y2milestone( "after getNfsInfo" );
	if( ret<0 )
	    y2warning( "getNfsInfo ret:%1", ret );
	foreach( any info, pinfos,
	    ``{
	    map p = $[];
	    vinfo = LibStorage::NfsInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["type"] = `nfs;
	    p["fstype"] = Partitions::nfs_name;
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    //y2milestone ("getContainerInfo container %1", remove( c, "partitions" ) );
    y2milestone ("getContainerInfo container %1", c );
    return( c );
    }

map toDiskMap( map disk, map cinfo )
    {
    list<string> l = [ "size_k", "cyl_size", "cyl_count", "label",
		       "max_logical", "max_primary", "type", "readonly",
		       "used_by_type", "used_by", "partitions", "dasdfmt",
		       "udev_id", "udev_path" ];
    foreach( string s, l,
	``{
	if( haskey( cinfo, s ) )
	    disk[s] = cinfo[s]:(any)0;
	else if( haskey( disk, s ))
	    disk = remove( disk, s );
	});
    return( disk );
    }

list<map> getContainers()
    ``{
    list<map> ret = [];
    list<any> cinfos = [];
    LibStorage::StorageInterface::getContainers( sint, cinfos );
    foreach( any info, cinfos,
	``{
	map c = $[];
	c["name"] = LibStorage::ContainerInfo::swig_name_get(info);
	c["device"] = LibStorage::ContainerInfo::swig_device_get(info);
	integer t = LibStorage::ContainerInfo::swig_type_get(info);
	c["type"] = toSymbol( conv_ctype, t );
	t = LibStorage::ContainerInfo::swig_usedBy_get(info);
	if( t!=LibStorage::UB_NONE() )
	    {
	    c["used_by_type"] = toSymbol( conv_usedby, t );
	    c["used_by"] = LibStorage::ContainerInfo::swig_usedByName_get(info);
	    }
	boolean b = LibStorage::ContainerInfo::swig_readonly_get(info);
	if( b )
	    c["readonly"] = true;
	ret = add( ret, c );
	});
    y2milestone( "getContainers ret:%1", ret );
    return( ret );
    };

integer count=0;

global void UpdateTargetMap()
    {
    conts = getContainers();
    list<string> rem_keys = [];
    map<string,map> tg = StorageMap[targets_key]:$[];
    //SCR::Write(.target.ycp, "/tmp/upd_all_bef_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    foreach( string dev, map disk, tg,
	``{
	map c = $[];
	c = find( map c, conts, ``(c["device"]:""==dev) );
	if( c==nil )
	    rem_keys = add( rem_keys, dev );
	else if( c["type"]:`CT_UNKNONW==`CT_DISK )
	    {
	    tg[dev] = toDiskMap( tg[dev]:$[], getContainerInfo( c ) );
	    y2milestone( "UpdateTargetMap dev:%1 is:%2", dev, tg[dev]:$[] );
	    }
	else
	    {
	    tg[dev] = getContainerInfo(c);
	    y2milestone( "UpdateTargetMap dev:%1 is:%2", dev, tg[dev]:$[] );
	    }
	});
    y2milestone( "UpdateTargetMap rem_keys:%1", rem_keys );
    foreach( string dev, rem_keys, ``{tg=remove(tg,dev);});
    foreach( map c, conts,
	``{
	if( c["type"]:`CT_UNKNOWN!=`CT_DISK && !haskey( tg, c["device"]:"" ))
	    {
	    tg[c["device"]:""] = getContainerInfo(c);
	    y2milestone( "UpdateTargetMap dev:%1 is:%2", c["device"]:"",
	                 tg[c["device"]:""]:$[] );
	    }
	});
    StorageMap[targets_key] = tg;
    //SCR::Write(.target.ycp, "/tmp/upd_all_aft_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    //count = count+1;
    }

define void UpdateTargetMapDisk( string dev )
    {
    y2milestone( "UpdateTargetMapDisk" );
    conts = getContainers();
    map c = $[];
    c = find( map c, conts, ``(c["device"]:""==dev) );
    map tg = StorageMap[targets_key]:$[];
    //SCR::Write(.target.ycp, "/tmp/upd_disk_bef_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    if( c==nil )
	{
	if( haskey( tg, dev ) )
	    tg = remove( tg, dev );
	}
    else if( c["type"]:`CT_UNKNONW==`CT_DISK )
	{
	tg[dev] = toDiskMap( tg[dev]:$[], getContainerInfo( c ) );
	}
    else
	{
	tg[dev] = getContainerInfo(c);
	}
    StorageMap[targets_key] = tg;
    //SCR::Write(.target.ycp, "/tmp/upd_disk_aft_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    //count = count+1;
    }

define void UpdateTargetMapDev( string dev )
    {
    map<string,map> tg = StorageMap[targets_key]:$[];
    //SCR::Write(.target.ycp, "/tmp/upd_dev_bef_"+sformat("%1",count), tg );
    string cdev="";
    foreach( string key, map d, tg,
	``{
	if( size(cdev)==0 &&
	    find( map p, d["partitions"]:[], ``(p["device"]:""==dev))!=nil )
	    cdev = d["device"]:"";
	});
    map c = $[];
    c = find( map c, conts, ``(c["device"]:""==cdev) );
    map disk = $[];
    if( c!=nil )
	{
	disk = getContainerInfo( c );
	}
    if( c!=nil && haskey( tg, cdev ))
	{
	list<map> partitions = tg[cdev,"partitions"]:[];
	boolean found = false;
	partitions = maplist( map p, partitions,
	    ``{
	    if( p["device"]:"" == dev )
		{
		map pp = find( map q, disk["partitions"]:[],
			       ``(q["device"]:""==dev));
		if( pp!=nil )
		    {
		    found = true;
		    p = pp;
		    }
		}
	    return( p );
	    });
	tg[disk["device"]:"","partitions"] = partitions;
	if( !found )
	    y2error( "UpdateTargetMapDev not found %1", dev );
	}
    else
	y2error( "UpdateTargetMapDev key %1 not found in target", disk["device"]:"" );
    StorageMap[targets_key] = tg;
    //SCR::Write(.target.ycp, "/tmp/upd_dev_aft_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    //count = count+1;
    }

global define map getDiskInfo( string device, map disk )
    {
    map c = $[];
    c = find( map p, conts, ``(p["device"]:""==device ));
    if( c==nil )
	{
	map tmp = GetDiskPartition( device );
	y2milestone( "getDiskInfo map %1", tmp );
	if( tmp["disk"]:"" != device )
	    c = find( map p, conts, ``(p["device"]:""==tmp["disk"]:"" ));
	}
    y2milestone( "getDiskInfo c:%1", c );
    if( c!=nil )
	{
	disk = toDiskMap( disk, getContainerInfo( c ) );
	}
    y2milestone( "getDiskInfo ret:%1", disk );
    return( disk );
    }

global define void SaveExitKey( symbol key )
    ``{
    if( key == `next || key == `back )
	{
	exit_key = key;
	y2milestone( "Exit Key %1", exit_key );
	}
    };

global define symbol GetExitKey()
    ``{
    return( exit_key );
    };

global define void SetLastUsed( string device )
    {
    if( size(device)>0 )
	last_used = device;
    }

global define string GetLastUsed()
    {
    return( last_used );
    }

global define map FindFstabEntry( map fstab, string mount, string device,
			          string uuid, string label )
    {
    map ret = $[];
    list lines = [];
    lines = FindFstabLines( fstab, mount, device, uuid, label );
    y2milestone( "mount=%1 device=%2 uuid=%3 label=%4", mount, device, uuid,
                 label );
    if( size(lines)>0 )
	{
	map entry = AsciiFile::GetLine( fstab, lines[0]:-1 );
	ret = $[ "spec" : entry["fields",0]:"",
	         "file" : entry["fields",1]:"",
	         "vfstype" : entry["fields",2]:"",
	         "mntops" : entry["fields",3]:"",
	         "freq" : entry["fields",4]:0,
	         "passno" : entry["fields",5]:0 ];
	}
    y2milestone( "ret:%1", ret );
    return( ret );
    }


global define map GetOndiskTarget()
    {
    list keys = [ "mount", "enc_type", "mountby", "fstopt", "used_fs", "format" ];
    map<string,map> ret = GetTargetMap();
    foreach( string d, map disk, ret,
	``{
	list<map> pl =
	    maplist( map<string,any> p, disk["partitions"]:[],
		     ``( filter( string k, any e, p, ``(!contains(keys,k)))));
	pl = maplist( map p, pl,
		      ``({
		      if( p["detected_fs"]:`unknown!=`unknown )
			  p["used_fs"] = p["detected_fs"]:`unknown;
		      return(p);
		      }));
	ret[d,"partitions"] = pl;
	});
    return( ret );
    }

global define void CreateTargetBackup(string who)
    {
    string t = "targetMap_s_" + who + "_" + sformat("%1",count);
    count = count+1;
    SCR::Write(.target.ycp, Storage::SaveDumpPath(t), GetTargetMap() );
    y2milestone( "CreateTargetBackup who:%1", who );
    integer ret = LibStorage::StorageInterface::createBackupState( sint, who );
    if( ret<0 )
	y2error( "CreateTargetBackup sint ret:%1", ret );
    }

global define void DisposeTargetBackup(string who)
    {
    y2milestone( "DisposeTargetBackup who:%1", who );
    integer ret = LibStorage::StorageInterface::removeBackupState( sint, who );
    if( ret<0 )
	y2error( "DisposeTargetBackup sint ret:%1", ret );
    }

global define boolean EqualBackupStates( string s1, string s2, boolean vb )
    {
    y2milestone( "EqualBackupStates s1:\"%1\" s2:\"%2\" verbose:%3",
                 s1, s2, vb );
    boolean ret = LibStorage::StorageInterface::equalBackupStates( sint, s1,
                                                                   s2, vb );
    y2milestone( "EqualBackupStates ret:%1", ret );
    return( ret );
    }

global define void RestoreTargetBackup( string who )
    {
    y2milestone( "RestoreTargetBackup who:%1", who );
    integer ret = LibStorage::StorageInterface::restoreBackupState( sint, who );
    if( ret<0 )
	y2error( "RestoreTargetBackup sint ret:%1", ret );
    UpdateTargetMap();
    string t = "targetMap_r_" + who;
    SCR::Write(.target.ycp, Storage::SaveDumpPath(t), GetTargetMap() );
    }

global define void ResetOndiskTarget()
    {
    RestoreTargetBackup( "initial" );
    }

global define integer GetTargetChangeTime()
    {
    return( StorageMap["targets_time"]:0 );
    }

global define boolean GetPartProposalActive()
    {
    return StorageMap[part_proposal_active_key]:true;
    };

global define void SetPartProposalActive( boolean value )
    {
    StorageMap[part_proposal_active_key] = value;
    };

global define string GetPartMode()
    {
    y2milestone( "GetPartMode %1", StorageMap[part_mode_key]:"" );
    return StorageMap[part_mode_key]:"";
    };

global define void SetPartMode( string value )
    {
    y2milestone( "SetPartMode %1", value );
    StorageMap[part_mode_key] = value;
    };

global define boolean GetCustomDisplay()
    {
    return StorageMap[custom_display_key]:false;
    };

global define void SetCustomDisplay( boolean value )
    {
    StorageMap[custom_display_key] = value;
    };

global define string GetPartDisk()
    {
    return StorageMap[part_disk_key]:"";
    };

global define void SetPartDisk( string value )
    {
    StorageMap[part_disk_key] = value;
    };


  global define boolean GetTestsuite()``{
      return StorageMap[testsuite_key]:false;
  }

  global define void SetTestsuite( boolean value ) ``{
      StorageMap = add( StorageMap, testsuite_key, value );
  }

  global define boolean GetLvmViewAllMnt()``{
      return StorageMap[lvm_view_all_mnt_key]:true;
  }

  global define void SetLvmViewAllMnt( boolean value ) ``{
      StorageMap = add( StorageMap, lvm_view_all_mnt_key, value );
  }

  global define boolean GetRaidtabCreated()``{
      return StorageMap[raidtab_created_key]:false;
  }

  global define void SetRaidtabCreated( boolean value ) ``{
      StorageMap = add( StorageMap, raidtab_created_key, value );
  }

  global define string GetDoResize()``{
      return StorageMap[do_resize_key]:"NO";
  }

  global define void SetDoResize( string value ) ``{
      StorageMap = add( StorageMap, do_resize_key, value );
  }

  global define string GetPartProposalMode()``{
      return StorageMap[part_proposal_mode_key]:"accept";
  }

  global define void SetPartProposalMode( string value ) ``{
      StorageMap = add( StorageMap, part_proposal_mode_key, value );
  }

  global define boolean GetWholeDisk()``{
      return StorageMap[whole_disk_key]:false;
  }

  global define void SetWholeDisk( boolean value ) ``{
      StorageMap = add( StorageMap, whole_disk_key, value );
  }

  global define boolean GetPartProposalFirst()``{
      return StorageMap[part_proposal_first_key]:true;
  }

  global define void SetPartProposalFirst( boolean value ) ``{
      StorageMap = add( StorageMap, part_proposal_first_key, value );
  }

  global define boolean GetWinDevice()``{
      return StorageMap[win_device_key]:false;
  }

  global define void SetWinDevice( boolean value ) ``{
      StorageMap = add( StorageMap, win_device_key, value );
    }




    /* StorageMaps =  [
       1: $[  storage_map_key		: 	$[ Storage_01],
              storage_type_key		:	`record,
	      ],
       2, $[ storage_map_key		: 	$[ Storage_02],
             storage_type_key		: 	`custom,
             storage_doc_key 		:	"create partition /dev/hda2"
	     ],
       3: $[ storage_map_key		:       $[ Storage_03 ],
             storage_type_key		:	`custom,
	     storage_doc_key		:	"delete partition /dev/hda1"
	     ],
       4: $[ storage_map_key		: 	$[ Storage_04 ],
             storage_type_key		: 	`record
	     ]
	];
    */



    /* Record - Rollback - Commit */
    /* update focus and Storage - StorageStack */

    /* Find the next free position in the map StorageMaps
     * @return integer
     */
    define integer NextStorageMapsPos() ``{
	return (size( StorageMaps) + 1);
    }


    define integer FindLastRecordEntry() ``{
	map<integer,any> all_record_entries = (map<integer,any>)filter (integer key, map entry , StorageMaps, ``( entry[storage_type_key]:custom_key == record_key ));
	list<integer> all_record_keys   = (list<integer>) maplist(integer key, any entry , all_record_entries,  ``(  key ));

	if( size( all_record_entries ) > 0 )
	    return sort(integer x, integer y, all_record_keys , ``(y < x))[0]:1;
	else return 0;
    }


    define void Rollback2Pos(integer pos ) ``{
	StorageMap = StorageMaps[pos,storage_map_key]:$[];
	StorageMaps = filter(integer key, map entry, StorageMaps, ``( key < pos ));
    }


    define void AddEntry2StorageMaps(symbol type_key, string doc )``{
	map storage_maps_entry = $[];

	storage_maps_entry = add(storage_maps_entry, storage_map_key  , StorageMap    );
	storage_maps_entry = add(storage_maps_entry, storage_type_key , type_key   );

	if( doc != "" )
	    storage_maps_entry = add(storage_maps_entry, storage_type_key , doc    );

	StorageMaps = add( StorageMaps, NextStorageMapsPos(), storage_maps_entry );
    }


    /**
     *
     * @return boolean
     */
    global define void Record()``{
	AddEntry2StorageMaps( record_key, "");
    }

    /**
     *
     * @return boolean
     */
    global define boolean Rollback()``{
	integer last_record_entry =  FindLastRecordEntry();
	if( last_record_entry != 0 )
	{
	    Rollback2Pos( last_record_entry );
	    return true;
	}
	else
	{
	    return false;
	}
    }

    /**
     *
     *	@return boolean
     */
global define boolean Commit()
    ``{
    integer last_record_entry = FindLastRecordEntry();
    if( last_record_entry != 0 )
	{
	StorageMaps = filter( integer key, map entry, StorageMaps,
			      ``( key < last_record_entry ));
	return true;
	}
    else
	{
	return false;
	}
    }

global define void InstallCallbacks()
    {
    StorageClients::InstallCallbacks();
    }


global define void Storage()
    ``{
    y2milestone( "constructor Storage()" );
    StorageMap[targets_backup_key] = $[];
    StorageMap[targets_backup_l_key] = $[];
    StorageMap[targets_backup_m_key] = $[];
    if( Mode::normal () )
	{
	Storage::SetPartMode( "CUSTOM" );
	Storage::SetPartProposalActive( false  );
	}
    InstallCallbacks();
    }


    /* Dev definitions

       dev     = maindev  | subdev
       maindev = "disk"   | "vg"	| "md" (raiddev)
       subdev  = "part"   | "lv" 	| "raid"

       e.g.: 	"disk" = "/dev/hda"	| "dev/sda"	| "/dev/hdd"  | ...
                "vg"   = "/dev/system" 	| "dev/group"   | ...
		"md"   = "/dev/md"  (only)
		"part" = "1//dev/hda"	| "2//dev/sda"	| ..
		"lv"   = "usr//dev/system" | "home//dev/system"
    */


    /* Key definitions

       key = maindevkey | subdevkey + maindevkey

       maindevkey	= key( disk | vg | md   )
       subdevkey	= key( part | lv | raid )
       subdevkey        = maindevkey + subdevindex | "all"

       subdevindex 	= 1 | 2 | "home" | "usr" | ..

       e.g.:
       maindevkey	= "/dev/hda"	| "/dev/md"	| "/dev/system"		| "all"
       subdevkey	= "1//dev/hda"	| "1//dev/md"	| "home//dev/system" 	| "all"


   */

    /* MainDev defines ------------------------------------------------------------------
    /* partition_defines -> isDisk */
    /* partition_defines -> isRaid */
    /* partition_defines -> isLVM  */
    symbol sw_raid_type_key = `sw_raid;
    symbol lvm_type_key	    = `lvm;
    symbol extended_type_key= `extended;





global define map<string,map> RemoveAllPartEntry( map<string,map> tg, string skey, string value )
    ``{
    map<string,map> new_tg = tg;

    foreach(string dev, map disk, tg,
	``{
	boolean changed = false;
	list new_partitions = [];
	foreach (map partition, disk["partitions"]:[],
	    ``{
	    if( partition[skey]:"" == value )
		{
		partition = filter(string key, any value_inner, (map<string,any>)partition, ``( key != skey));
		changed = true;
		}
	    new_partitions = add( new_partitions , partition);
	    });

	if( changed )
	    {
	    disk["partitions"] = new_partitions;
	    new_tg[dev] = disk;
	    }
	});
    return( new_tg );
    };

global define list<map> RenumberS390Partitions( string dname,
                                                list<map> partitions )
    ``{
    integer cnt = 1;
    partitions = sort( map a, map b, partitions,
                       ``(a["region",0]:0<b["region",0]:0));
    partitions = maplist( map p, partitions,
	``{
	if( p["nr"]:0 != cnt )
	    {
	    if( !haskey( p, "ori_nr" ) )
		{
		p["ori_nr"] = p["nr"]:0;
		}
	    p["nr"] = cnt;
	    p["device"] = GetDeviceName( dname, cnt );
	    }
	cnt = cnt+1;
	return( p );
	});
    y2milestone( "RenumberS390Partions %1", partitions );
    return( partitions );
    }

global define map<string, map>
RenameTgDevices( map<string, map> tg, map<string, string> ren )
    ``{
    y2milestone( "RenameTgDevices ren:%1", ren );
    foreach( string dev, map co, tg,
	``{
	if( search( dev, "/dev/evms/" ) == 0 )
	    {
	    y2milestone( "RenameTgDevices before added:%1 removed:%2",
	                 co["added"]:[], co["removed"]:[] );
	    if( size(co["added"]:[])>0 )
		{
		co["added"] =
		    maplist( string d, co["added"]:[],
			     ``(haskey( ren, d )?(ren[d]:""):d));
		}
	    if( size(co["removed"]:[])>0 )
		{
		co["removed"] =
		    maplist( string d, co["removed"]:[],
			     ``(haskey( ren, d )?(ren[d]:""):d));
		}
	    y2milestone( "RenameTgDevices after added:%1 removed:%2",
	                 co["added"]:[], co["removed"]:[] );
	    tg[dev] = co;
	    }
	});
    return( tg );
    }

global define map<integer, map>
RenameMtDevices( map<integer, map> mt, map<string, string> ren )
    ``{
    y2milestone( "RenameMtDevices ren:%1", ren );
    foreach( integer num, map entry, mt,
	``{
	if( entry["type"]:""=="create_vg" && size(entry["devices"]:[])>0 )
	    {
	    y2milestone( "RenameMtDevices before entry:%1", entry );
	    entry["devices"] =
		maplist( string d, entry["devices"]:[],
			 ``(haskey( ren, d )?(ren[d]:""):d));
	    y2milestone( "RenameMtDevices after entry:%1", entry );
	    mt[num] = entry;
	    }
	if( (entry["type"]:""=="create_pv" || entry["type"]:""=="remove_pv") &&
	    haskey( ren, entry["device"]:"" ))
	    {
	    y2milestone( "RenameMtDevices before entry:%1", entry );
	    entry["device"] = ren[entry["device"]:""]:"";
	    y2milestone( "RenameMtDevices after entry:%1", entry );
	    mt[num] = entry;
	    }
	});
    return( mt );
    }

global map NextPartition( string disk, symbol ptype )
    {
    y2milestone( "NextPartition disk:%1 ptype:%2", disk, ptype );
    map ret = $[];
    integer pt = fromSymbol(conv_ptype,ptype);
    y2milestone( "NextPartition type:%1 pt:%2", ptype, pt );
    integer num = 0;
    string dev = "";
    integer r = LibStorage::StorageInterface::nextFreePartition( sint, disk,
                                                                 pt, num, dev );
    if( r<0 )
	y2error( "NextPartition ret %1", r );
    ret["device"] = dev;
    ret["nr"] = num;
    y2milestone( "NextPartition sint ret:%1 map:%2", r, ret );
    return( ret );
    }

global integer MaxSizeLabelK( map disk )
    {
    integer ret = 0;
    string tmp = disk["label"]:"";
    ret = LibStorage::StorageInterface::maxSizeLabelK( sint, tmp );
    y2milestone( "MaxSizeLabelK %1 is %2", disk["label"]:"", ret );
    return( ret );
    }

global integer MaxCylLabel( map disk, integer start_cyl )
    {
    integer ret = MaxSizeLabelK(disk);
    y2milestone( "MaxCylLabel val_k:%1 cyl_size:%2", ret, disk["cyl_size"]:1 );
    integer cylk2 = disk["cyl_size"]:1/512;
    if( cylk2<2 )
	cylk2 = 2;
    y2milestone( "MaxCylLabel val_k:%1 cylk2:%2", ret, cylk2 );
    ret = ret*2 / cylk2 - 1;
    ret = ret + start_cyl;
    y2milestone( "MaxCylLabel ret:%1", ret );
    return( ret );
    }

global boolean CreatePartition( string disk, string device, symbol ptype,
                                integer id, integer start, integer len,
				symbol mby )
    {
    y2milestone( "CreatePartition disk:%1 device:%2 ptype:%3 id:%4 start:%5 len:%6 mby:%7",
                 disk, device, ptype, id, start, len, mby );
    string cdev = "";
    integer pt = fromSymbol(conv_ptype,ptype);
    y2milestone( "CreatePartition type:%1 pt:%2", ptype, pt );
    integer ret = LibStorage::StorageInterface::createPartition( sint, disk, pt,
								 start, len,
								 cdev );
    if( device!=cdev )
	y2error( "CreatePartition device:%1 cdev:%2", device, cdev );
    if( ret<0 )
	y2error( "CreatePartition ret %1", ret );
    ret = LibStorage::StorageInterface::changePartitionId( sint, device,
							   id );
    if( ret<0 )
	y2error( "CreatePartition ret %1", ret );
    integer tmp = fromSymbol( conv_mountby, mby );
    LibStorage::StorageInterface::changeMountBy( sint, device, tmp );
    y2milestone( "CreatePartition sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean UpdatePartition( string device, integer start, integer len )
    {
    y2milestone( "UpdatePartition device:%1 start:%2 len:%3",
                 device, start, len );
    integer ret = 0;
    ret = LibStorage::StorageInterface::updatePartitionArea( sint, device,
							     start, len );
    if( ret<0 )
	y2error( "UpdatePartition sint ret:%1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean SetPartitionMount( string device, string mp )
    {
    y2milestone( "SetPartitionMount device:%1 mp:%2", device, mp );
    integer ret = 0;
    ret = LibStorage::StorageInterface::changeMountPoint( sint, device, mp );
    if( ret<0 )
	y2error( "SetPartitionMount sint ret:%1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean SetPartitionFormat( string device, boolean format, symbol fs )
    {
    y2milestone( "SetPartitionFormat device:%1 format:%2 fs:%3", device,
                 format, fs );
    integer ret = 0;
    integer tmp = fromSymbol( FileSystems::conv_fs, fs );
    y2milestone( "SetPartitionFormat fs:%1", tmp );
    ret = LibStorage::StorageInterface::changeFormatVolume( sint, device,
                                                            format, tmp );
    if( ret<0 )
	y2error( "SetPartitionFormat sint ret:%1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean SetPartitionId( string device, integer id )
    {
    y2milestone( "SetPartitionId device:%1 id:%2", device, id );
    integer ret = 0;
    ret = LibStorage::StorageInterface::changePartitionId( sint, device, id );
    if( ret<0 )
	y2error( "SetPartitionId sint ret:%1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean UnchangePartitionId( string device )
    {
    y2milestone( "UnchangePartitionId device:%1", device );
    integer ret = 0;
    ret = LibStorage::StorageInterface::forgetChangePartitionId( sint, device );
    if( ret<0 )
	y2error( "UnchangePartitionId sint ret:%1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean ResizeVolume( string device, string disk, integer new_size )
    {
    y2milestone( "ResizeVolume device:%1 disk:%2 new_size:%3", device, disk,
                 new_size );
    integer ret = 0;
    ret = LibStorage::StorageInterface::resizeVolume( sint, device,
                                                      (new_size+1023)/1024 );
    if( ret<0 )
	y2error( "ResizeVolume sint ret:%1", ret );
    UpdateTargetMapDisk( disk );
    return( ret==0 );
    }

global boolean SetCrypt( string device, boolean crpt, boolean format )
    {
    y2milestone( "SetCrypt device:%1 val:%2 format:%3", device, crpt, format );
    boolean is_crypt = false;
    integer ret = LibStorage::StorageInterface::getCrypt( sint, device, 
                                                          is_crypt );
    if( ret==0 && !format && is_crypt==crpt )
	y2milestone( "SetCrypt crypt already set" );
    else
	{
	ret = LibStorage::StorageInterface::setCrypt( sint, device, crpt );
	if( ret<0 )
	    {
	    y2error( "SetCrypt sint ret:%1", ret );
	    if( !format && crpt )
		Popup::Error( sformat(_("Could not set encryption.
System error code is %1.

The crypt password provided could be incorrect.
"), ret ));
	    LibStorage::StorageInterface::forgetCryptPassword( sint, device );
	    }
	else
	    y2milestone( "SetCrypt sint ret:%1", ret );
	}
    return( ret==0 );
    }

integer ChangeDescText( string dev, string txt )
    {
    integer ret = LibStorage::StorageInterface::changeDescText( sint, dev, txt );
    return( ret );
    }

global boolean ChangeVolumeProperties( map part )
    {
    integer ret = 0;
    integer tmp = 0;
    boolean changed = false;
    string ts = "";
    string dev = part["device"]:"";
    any vinfo = LibStorage::VolumeInfo::new("LibStorage::VolumeInfo");
    ret = LibStorage::StorageInterface::getVolume( sint, dev, vinfo );
    if( ret!=0 )
	y2error( "ChangeVolumeProperties device:%1 not found", dev );
    map curr = $[];
    if( ret==0 )
	{
	curr = volumeMap( vinfo, curr );
	}
    if( ret==0 && part["mount"]:"" != curr["mount"]:"" )
	{
	changed = true;
	ts = part["mount"]:"";
	ret = LibStorage::StorageInterface::changeMountPoint( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && part["type"]:`unknown != `extended &&
        (part["format"]:false != curr["format"]:false ||
         part["used_fs"]:`none != curr["used_fs"]:`none) )
	{
	changed = true;
	tmp = fromSymbol(FileSystems::conv_fs,part["used_fs"]:`none);
	y2milestone( "ChangeVolumeProperties fs:%1 symbol:%2", tmp, part["used_fs"]:`none );
	ret = LibStorage::StorageInterface::changeFormatVolume( sint, dev,
								part["format"]:false,
								tmp );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 &&
        size(part["mount"]:"")>0 && part["fstopt"]:"" != curr["fstopt"]:"" )
	{
	changed = true;
	ts = part["fstopt"]:"";
	ret = LibStorage::StorageInterface::changeFstabOptions( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && size(part["mount"]:"")>0 &&
        part["mountby"]:`id != curr["mountby"]:`id )
	{
	changed = true;
	tmp = fromSymbol(conv_mountby,part["mountby"]:`device);
	y2milestone( "ChangeVolumeProperties mby:%1", tmp );
	ret = LibStorage::StorageInterface::changeMountBy( sint, dev, tmp );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && part["label"]:"" != curr["label"]:"" )
	{
	changed = true;
	ts = part["label"]:"";
	ret = LibStorage::StorageInterface::changeLabelVolume( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && part["format"]:false && 
	convertFsOptionMapToString(part["fs_options"]:$[]) != curr["mkfs_opt"]:"" )
	{
	changed = true;
	ts = convertFsOptionMapToString(part["fs_options"]:$[]);
	y2milestone( "FsOption ts:%1", ts );
	ret = LibStorage::StorageInterface::changeMkfsOptVolume( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 &&
        part["enc_type"]:`none != `none && haskey( ClassifiedSettings, dev ) )
	{
	changed = true;
        if( size(ClassifiedSettings[dev]:"")>0 )
	    {
	    string pwd = ClassifiedSettings[dev]:"";
	    ret = LibStorage::StorageInterface::setCryptPassword( sint, dev,
								  pwd );
	    if( ret<0 )
		y2error( "ChangeVolumeProperties sint ret:%1", ret );
	    else
		y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	    }
	}
    if( ret==0 && part["enc_type"]:`none != curr["enc_type"]:`none )
	{
	changed = true;
	SetCrypt( dev, part["enc_type"]:`none!=`none, part["format"]:false );
	}
    if( ret==0 && part["dtxt"]:"" != curr["dtxt"]:"" )
	{
	changed = true;
	ret = ChangeDescText( dev, part["dtxt"]:"" );
	}
    if( ret==0 &&
        ((part["resize"]:false && part["region",1]:0 != curr["region",1]:0) ||
	 (part["resize"]:false != curr["resize"]:false)) )
	{
	changed = true;
	string d = part["device"]:"";
	integer i = part["region",1]:0;
	if( part["resize"]:false )
	    {
	    y2milestone( "ChangeVolumeProperties resize to %1 cyl", i );
	    if( part["ignore_fs"]:false )
		ret = LibStorage::StorageInterface::resizePartitionNoFs( sint, d, i );
	    else
		ret = LibStorage::StorageInterface::resizePartition( sint, d, i );
	    }
	else
	    ret = LibStorage::StorageInterface::forgetResizeVolume( sint, d );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && 
        part["change_fsid"]:false && part["fsid"]:0 != curr["fsid"]:0)
	{
	changed = true;
	string d = part["device"]:"";
	integer i = part["fsid"]:0;
	y2milestone( "ChangeVolumeProperties fsid to %1", i );
	ret = LibStorage::StorageInterface::changePartitionId( sint, d, i );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret:%1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 )
	{
	y2debug( "ChangeVolumeProperties changed:%1 part:%2", changed, part );
	if( changed )
	    UpdateTargetMapDev( dev );
	}
    return( ret==0 );
    }

global boolean DeleteDevice( string disk, string device )
    {
    y2milestone( "DeleteDevice disk:%1 device:%2", disk, device );
    integer ret = LibStorage::StorageInterface::removeVolume( sint, device );
    if( ret<0 )
	y2error( "DeleteDevice sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean DeleteLvmVg( string name )
    {
    y2milestone( "DeleteLvmVg name:%1", name );
    integer ret = LibStorage::StorageInterface::removeLvmVg( sint, name );
    if( ret<0 )
	y2error( "DeleteLvmVg sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean CreateLvmVg( string name, integer pesize, boolean lvm2 )
    {
    y2milestone( "CreateLvmVg name:%1 pesize:%2 lvm2:%3", name, pesize, lvm2 );
    list<string> devs = [];
    integer ret = 0;
    ret = LibStorage::StorageInterface::createLvmVg( sint, name, pesize/1024,
                                                     !lvm2, devs );
    if( ret<0 )
	y2error( "CreateLvmVg sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ExtendLvmVg( string name, string device )
    {
    y2milestone( "ExtendLvmVg name:%1 device:%2", name, device );
    integer ret = 0;
    list<string> devs = [ device ];
    ret = LibStorage::StorageInterface::extendLvmVg( sint, name, devs );
    if( ret<0 )
	y2error( "ExtendLvmVg sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ReduceLvmVg( string name, string device )
    {
    y2milestone( "ReduceLvmVg name:%1 device:%2", name, device );
    integer ret = 0;
    list<string> devs = [ device ];
    ret = LibStorage::StorageInterface::shrinkLvmVg( sint, name, devs );
    if( ret<0 )
	y2error( "ReduceLvmVg sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean CreateLvmLv( string vgname, string lvname, integer sizeK,
                            integer stripe )
    {
    y2milestone( "CreateLvmLv vg:%1 name:%2 sizeK:%3 stripe:%4", vgname,
                 lvname, sizeK, stripe );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::createLvmLv( sint, vgname, lvname,
                                                     (sizeK+1023)/1024, stripe,
						     dummy );
    if( ret<0 )
	y2error( "CreateLvmLv sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/"+vgname );
    return( ret==0 );
    }

global boolean ChangeLvStripeSize( string vgname, string lvname,
				   integer stripeSize )
    {
    y2milestone( "ChangeLvStripeSize vg:%1 name:%2 stripeSize:%3", vgname,
                 lvname, stripeSize );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::changeLvStripeSize( sint, vgname,
                                                            lvname,
							    stripeSize );
    if( ret<0 )
	y2error( "ChangeLvStripeSize sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/"+vgname );
    return( ret==0 );
    }

global boolean ChangeLvStripeCount( string vgname, string lvname,
				    integer stripes )
    {
    y2milestone( "ChangeLvStripeCount vg:%1 name:%2 stripes:%3", vgname,
                 lvname, stripes );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::changeLvStripeCount( sint, vgname,
                                                             lvname,
							     stripes );
    if( ret<0 )
	y2error( "ChangeLvStripeCount sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/"+vgname );
    return( ret==0 );
    }

global boolean DeleteEvmsCo( string name )
    {
    y2milestone( "DeleteEvmsCo name:%1", name );
    integer ret = LibStorage::StorageInterface::removeEvmsContainer( sint, name );
    if( ret<0 )
	y2error( "DeleteEvmsCo sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global string EvmsShortName( string lname )
    {
    string sname = lname;
    if( search( sname, "/" )!=nil )
	sname = substring( sname, search( sname, "/" )+1 );
    return( sname );
    }

global boolean ActivateEvms()
    {
    integer ret = 0;
    y2milestone( "Mode:%1", Mode::mode() );
    ret = LibStorage::StorageInterface::evmsActivate( sint, Mode::update() );
    if( ret<0 )
	y2error( "activateEvms sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global list EvmsTrivialMaps( map tgMap )
    {
    string regex1 = "[0-9]+$";
    y2milestone( "EvmsTrivialMaps %1", tgMap["/dev/evms","partitions"]:[] );
    list ps = filter( map p, tgMap["/dev/evms","partitions"]:[],
		      ``(size(regexppos(p["name"]:"",regex1))>0));
    y2milestone( "EvmsTrivialMaps %1", ps );
    return( ps );
    }

global boolean CreateEvmsCo( string name, integer pesize, boolean lvm2 )
    {
    y2milestone( "CreateEvmsCo name:%1 pesize:%2 lvm2:%3", name, pesize, lvm2 );
    string sname = EvmsShortName( name );
    y2milestone( "CreateEvmsCo sname:%1", sname );
    list<string> devs = [];
    integer ret = 0;
    ret = LibStorage::StorageInterface::createEvmsContainer( sint, sname,
                                                             pesize/1024,
							     !lvm2, devs );
    if( ret<0 )
	y2error( "CreateEvmsCo sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ModifyEvmsCo( string old_name, string new_name, integer pesize,
                             boolean lvm2 )
    {
    y2milestone( "ModifyEvmsCo old name:%1 new name:%2 pesize:%3 lvm2:%4",
                 old_name, new_name, pesize, lvm2 );
    string sname = EvmsShortName( old_name );
    y2milestone( "CreateEvmsCo sname:%1", sname );
    list<string> devs = [];
    integer ret = 0;
    ret = LibStorage::StorageInterface::modifyEvmsContainer( sint, sname,
                                                             new_name,
							     pesize/1024,
							     !lvm2 );
    if( ret<0 )
	y2error( "ModifyEvmsCo sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ExtendEvmsCo( string name, string device )
    {
    y2milestone( "ExtendEvmsCo name:%1 device:%2", name, device );
    integer ret = 0;
    string sname = EvmsShortName( name );
    y2milestone( "ExtendEvmsCo sname:%1", sname );
    list<string> devs = [ device ];
    ret = LibStorage::StorageInterface::extendEvmsContainer( sint, sname,
                                                             devs );
    if( ret<0 )
	y2error( "ExtendEvmsCo sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ReduceEvmsCo( string name, string device )
    {
    y2milestone( "ReduceEvmsCo name:%1 device:%2", name, device );
    integer ret = 0;
    string sname = EvmsShortName( name );
    y2milestone( "ReduceEvmsCo sname:%1", sname );
    list<string> devs = [ device ];
    ret = LibStorage::StorageInterface::shrinkEvmsContainer( sint, sname,
                                                             devs );
    if( ret<0 )
	y2error( "ReduceEvmsCo sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean CreateEvmsVolume( string coname, string lvname, integer sizeK,
				 integer stripe )
    {
    y2milestone( "CreateEvmsVolume vg:%1 name:%2 sizeK:%3 stripe:%4", coname,
                 lvname, sizeK, stripe );
    integer ret = 0;
    string dummy = "";
    string sname = EvmsShortName( coname );
    y2milestone( "CreateEvmsVolume sname:%1", sname );
    ret = LibStorage::StorageInterface::createEvmsVolume( sint, sname, lvname,
                                                          (sizeK+1023)/1024,
							  stripe, dummy );
    if( ret<0 )
	y2error( "CreateEvmsVolume sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/evms/"+coname );
    return( ret==0 );
    }

global boolean ChangeEvmsStripeCount( string coname, string name,
				      integer stripe )
    {
    y2milestone( "ChangeEvmsStripeCount co:%1 name:%2 stripe:%3", coname,
                 name, stripe );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::changeEvmsStripeCount( sint, coname,
							       name, stripe );
    if( ret<0 )
	y2error( "ChangeEvmsStripeCount sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/evms/"+coname );
    return( ret==0 );
    }

global boolean ChangeEvmsStripeSize( string coname, string name,
				     integer stripeSize )
    {
    y2milestone( "ChangeEvmsStripeSize co:%1 name:%2 stripeSize:%3", coname,
                 name, stripeSize );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::changeEvmsStripeSize( sint, coname,
							      name,
							      stripeSize );
    if( ret<0 )
	y2error( "ChangeEvmsStripeSize sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/evms/"+coname );
    return( ret==0 );
    }

global boolean AddNfsVolume( string nfsdev, string opts, integer sz, string mp )
    {
    y2milestone( "AddNfsVolume dev:%1 opts:%2 size:%3 mp:%4", nfsdev, opts, 
                 sz, mp );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::addNfsDevice( sint, nfsdev, opts, sz, mp );
    if( ret<0 )
	y2error( "AddNfsVolume sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/nfs" );
    return( ret==0 );
    }

global integer CheckNfsVolume( string nfsdev, string opts )
    {
    y2milestone( "CheckNfsVolume dev:%1 opts:%2", nfsdev, opts );
    integer ret = 0;
    integer sz = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::checkNfsDevice( sint, nfsdev, opts, 
                                                        sz );
    if( ret<0 )
	y2error( "CheckNfsVolume sint ret:%1", ret );
    else 
	ret = sz;
    y2milestone( "CheckNfsVolume ret:%1", ret );
    return( ret );
    }

global boolean CreateMd( integer nr, string type )
    {
    y2milestone( "CreateMd nr:%1 type:%2", nr, type );
    integer ret = 0;
    integer tmp = conv_mdstring[type]:0;
    list<string> dummy = [];
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::createMd( sint, rd, tmp, dummy );
    if( ret<0 )
	y2error( "CreateMd sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/md" );
    return( ret==0 );
    }

global boolean ExtendMd( integer nr, string dev )
    {
    y2milestone( "ExtendMd nr:%1 dev:%2", nr, dev );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::extendMd( sint, rd, dev );
    if( ret<0 )
	y2error( "ExtendMd sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ShrinkMd( integer nr, string dev )
    {
    y2milestone( "ShrinkMd nr:%1 dev:%2", nr, dev );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::shrinkMd( sint, rd, dev );
    if( ret<0 )
	y2error( "ShrinkMd sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ChangeMdType( integer nr, string mdtype )
    {
    y2milestone( "ChangeMdType nr:%1 mdtype:%2", nr, mdtype );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    integer tmp = conv_mdstring[mdtype]:0;
    ret = LibStorage::StorageInterface::changeMdType( sint, rd, tmp );
    if( ret<0 )
	y2error( "ChangeMdType sint ret:%1", ret );
    UpdateTargetMapDev( rd );
    return( ret==0 );
    }

global boolean ChangeMdParity( integer nr, string ptype )
    {
    y2milestone( "ChangeMdParity nr:%1 parity:%2", nr, ptype );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    integer tmp = conv_mdstring[ptype]:0;
    ret = LibStorage::StorageInterface::changeMdParity( sint, rd, tmp );
    if( ret<0 )
	y2error( "ChangeMdParity sint ret:%1", ret );
    UpdateTargetMapDev( rd );
    return( ret==0 );
    }

global boolean ChangeMdChunk( integer nr, integer chunk )
    {
    y2milestone( "ChangeMdChunk nr:%1 chunk:%2", nr, chunk );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::changeMdChunk( sint, rd, chunk );
    if( ret<0 )
	y2error( "ChangeMdChunk sint ret:%1", ret );
    UpdateTargetMapDev( rd );
    return( ret==0 );
    }

global integer CheckMd( integer nr )
    {
    y2milestone( "CheckMd nr:%1", nr );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::checkMd( sint, rd );
    if( ret!=0 )
	y2milestone( "CheckMd sint ret:%1", ret );
    return( ret );
    }

global string CreateLoop( string file, boolean create, integer sizeK,
                          string mp )
    {
    y2milestone( "CreateLoop file:%1 create:%2 sizeK:%3 mp:%4", file, create,
                 sizeK, mp );
    string dev = "";
    integer ret = -9999;
    if( haskey( ClassifiedSettings, file ))
	{
	string pwd = ClassifiedSettings[file]:"";
	ret = LibStorage::StorageInterface::createFileLoop( sint, file, !create,
							    sizeK, mp, pwd,
							    dev );
	}
    if( ret<0 )
	y2error( "CreateLoop sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/loop" );
    y2milestone( "CreateLoop dev:%1", dev );
    return( dev );
    }

integer loop_count = 0;

global string GetLoopDevice()
    {
    y2milestone( "GetLoopDevice" );
    string file = Directory::tmpdir + sformat("/dfile_%1", loop_count);
    string mp = Directory::tmpdir + sformat("/loopmp_%1", loop_count);
    loop_count = loop_count + 1;
    string dev = "";
    string pwd = "emilemil";
    integer ret = LibStorage::StorageInterface::createFileLoop( sint, file,
								true, 50*1024,
								mp, pwd, dev );
    if( ret<0 )
	y2error( "GetLoopDevice sint ret:%1", ret );
    LibStorage::StorageInterface::forgetCryptPassword( sint, dev );
    y2milestone( "GetLoopDevice dev:%1", dev );
    return( dev );
    }

global void UpdateClassified( string key, string pwd )
    {
    ClassifiedSettings[key] = pwd;
    //y2milestone( "ClassifiedSettings %1", ClassifiedSettings );
    }

global boolean UpdateLoop( string dev, string file, boolean create, 
                           integer sizeK )
    {
    y2milestone( "UpdateLoop device:%1 file:%2 create:%3 sizeK:%4", 
                 dev, file, create, sizeK );
    integer ret = LibStorage::StorageInterface::modifyFileLoop( sint, dev, file,
								!create,
								sizeK );
    if( ret<0 )
	y2error( "UpdateLoop sint ret:%1", ret );
    UpdateTargetMapDisk( "/dev/loop" );
    return( ret==0 );
    }

global boolean DeleteLoop( string disk, string file, boolean remove_file )
    {
    y2milestone( "DeleteLoop disk:%1 file:%2 remove_file:%3", disk, file,
                 remove_file );
    integer ret = LibStorage::StorageInterface::removeFileLoop( sint, file,
                                                                remove_file );
    if( ret<0 )
	y2error( "DeleteLoop sint ret:%1", ret );
    UpdateTargetMapDisk( disk );
    return( ret==0 );
    }

global string GetCryptPwd( string device )
    {
    string pwd="";
    y2milestone( "GetCryptPwd device:%1", device );
    if( size(ClassifiedSettings[device]:"")>0 )
	pwd = ClassifiedSettings[device]:"";
    else
	{
	integer ret = 0;
	ret = LibStorage::StorageInterface::getCryptPassword( sint, device,
							      pwd );
	if( ret<0 )
	    y2error( "GetCryptPwd sint ret:%1", ret );
	}
    y2milestone( "GetCryptPwd empty:%1", size(pwd)==0 );
    //y2milestone( "GetCryptPwd pwd:%1", pwd );
    return( pwd );
    }

global boolean SetCryptPwd( string device, string pwd )
    {
    y2milestone( "SetCryptPwd device:%1", device );
    //y2milestone( "SetCryptPwd pwd:%1", pwd );
    integer ret = LibStorage::StorageInterface::setCryptPassword( sint, device,
                                                                  pwd );
    y2milestone( "SetCryptPwd sint ret:%1", ret );
    map p = GetPartition( GetTargetMap(), device );
    if( ret==LibStorage::STORAGE_VOLUME_NOT_FOUND() || p["create"]:false )
	{
	ClassifiedSettings[device] = pwd;
	y2milestone( "setting classified %1 pwd size %2", device, size(pwd) );
	ret = 0;
	}
    else if( ret<0 )
	y2error( "SetCryptPwd sint ret:%1", ret );
    return( ret==0 );
    }

/**
 * Delete the partition table and disk label of device
 * @param string the disk to deleted the partition table from
 * @return boolean
 */
global define boolean DeletePartitionTable(string disk, integer size_k)
    ``{
    y2milestone( "DeletePartitionTable %1 size_k:%2", disk, size_k );
    string label = 
	LibStorage::StorageInterface::defaultDiskLabelSize( sint, size_k );
    y2milestone( "DeletePartitionTable label:%1", label );
    integer ret =
	LibStorage::StorageInterface::destroyPartitionTable( sint, disk,
	                                                     label );
    if( ret<0 )
	y2error( "DeletePartitionTable sint ret:%1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }


global string DefaultDiskLabel(integer size_k)
{
    y2milestone("DefaultDiskLabel size_k:%1", size_k);
    string label = LibStorage::StorageInterface::defaultDiskLabelSize(sint, size_k);
    y2milestone("DefaultDiskLabel label:%1", label);
    return label;
}


global boolean CreatePartitionTable(string disk, string label)
{
    y2milestone("CreatePartitionTable %1 label:%2", disk, label);
    integer ret = LibStorage::StorageInterface::destroyPartitionTable(sint, disk, label);
    if (ret < 0)
	y2error("CreatePartitionTable sint ret:%1", ret);
    UpdateTargetMap();
    return ret == 0;
}


global symbol GetMountBy( string device );

/**
 * Set the flag if a disk needs to be initialized
 * @param string the disk to be changed
 * @return boolean
 */
global define boolean InitializeDisk(string disk, boolean value)
    ``{
    boolean rbool = true;
    y2milestone( "InitializeDisk %1 value %2", disk, value );
    integer ret =
	LibStorage::StorageInterface::initializeDisk( sint, disk, value );
    if( ret<0 )
	{
	y2error( "InitializeDisk sint ret:%1", ret );
	rbool = false;
	}
    if( rbool && value )
	{
	map<string,any> d = GetDisk( GetTargetMap(), disk );
	y2milestone( "d:%1", d );
	rbool = CreatePartition( disk, disk+"1", `primary,
	                         Partitions::fsid_native,
				 0, d["cyl_count"]:1,
				 GetMountBy( disk+"1" ) );
	if( !rbool )
	    y2error( "InitializeDisk create failed" );
	}
    UpdateTargetMapDisk( disk );
    return( rbool );
    }

global define boolean CreateAny( symbol ctype, map d, map& p )
    {
    boolean ret = true;
    if( ctype == `CT_DISK )
	{
	ret = Storage::CreatePartition( d["device"]:"", p["device"]:"",
				        p["type"]:`primary,
				        p["fsid"]:Partitions::fsid_native,
				        p["region",0]:0, p["region",1]:0,
					p["mountby"]:GetMountBy( p["device"]:"" ) );
	}
    else if( ctype == `CT_MD )
	{
	ret = Storage::CreateMd( p["nr"]:0, p["raid_type"]:"raid1" );
	if( ret && haskey( p, "chunk_size" ))
	    Storage::ChangeMdChunk( p["nr"]:0, p["chunk_size"]:4 );
	if( ret && p["raid_type"]:""=="raid5" &&
	    haskey( p, "parity_algorithm" ))
	    Storage::ChangeMdParity( p["nr"]:0,
	                             p["parity_algorithm"]:"" );
	foreach( string d, p["devices"]:[],
		 ``{ret=Storage::ExtendMd( p["nr"]:0, d )&&ret;});
	}
    else if( ctype == `CT_LOOP )
	{
	y2milestone( "CreateAny Loop p:%1", p );
	string dev = Storage::CreateLoop( p["fpath"]:"", p["create_file"]:false,
					  p["size_k"]:0, p["mount"]:"" );
	ret = size(dev)>0;
	if( ret )
	    p["device"] = dev;
	}
    else if( ctype == `CT_LVM )
	{
	ret = Storage::CreateLvmLv( d["name"]:"", p["name"]:"", p["size_k"]:0,
				    p["stripes"]:1 );
	if( ret && p["stripes"]:1>1 && p["stripesize"]:0>0 )
	    {
	    Storage::ChangeLvStripeSize( d["name"]:"", p["name"]:"",
	                                 p["stripesize"]:0 );
	    }
	}
    else if( ctype == `CT_EVMS )
	{
	ret = Storage::CreateEvmsVolume( d["name"]:"", p["name"]:"",
	                                 p["size_k"]:0, p["stripes"]:1 );
	if( ret && p["stripes"]:1>1 && p["stripesize"]:0>0 )
	    {
	    Storage::ChangeEvmsStripeSize( d["name"]:"", p["name"]:"",
					   p["stripesize"]:0 );
	    }
	}
    else if( ctype == `CT_NFS )
	{
	ret = Storage::AddNfsVolume( p["device"]:"", p["fstopt"]:"", 
	                             p["size_k"]:0, p["mount"]:"" );
	}
    y2milestone( "CreateAny ret:%1", ret );
    return( ret );
    }

define boolean IsEfiPartition( map p )
    {
    map m = GetFreeSpace( p["device"]:"", 0, p["used_fs"]:`none, false );
    boolean ret = m["efi"]:false;
    y2milestone( "IsEfiPartition ret:%1", ret );
    return( ret );
    }

/**
 * Search in the list partitions for windows partitions and add the key
 * "mount" to the found windows partitions.
 * @parm partitions the partitions list
 * @parm primary handle primary or logical partitions
 * @return list new partitions with windows mountpoints
 */
define void AddMountPointsForWinParts( list<map> partitions, boolean primary,
                                       integer max_prim, integer& foreign_nr )
    ``{
    if( !Arch::i386 () && !Arch::ia64 () && !Arch::x86_64 () )
	return;

    string foreign_ids = "CDEFGHIJKLMNOPQRSTUVW";

    list<map> new_partitions = [];

    foreach(map partition, partitions,
	``{
	map new_partition = partition;
	integer fsid      = partition["fsid"]:Partitions::fsid_native;
	integer partnum = 0;
	if( haskey( partition, "nr") && is( partition["nr"]:(any)0, integer ) )
	    {
	    partnum = partition["nr"]:0;
	    }

	if( !haskey( partition, "mount") &&
	    !partition["delete"]:false &&
	    ((partnum<=max_prim)==primary) &&
	    foreign_nr < 24 &&
	    Partitions::IsDosWinNtPartition(fsid) &&
	    (!Arch::ia64() || !IsEfiPartition(partition)) &&
	    contains( [`vfat, `ntfs], partition["used_fs"]:`none ))
	    {
	    new_partition["fstopt"] = 
		FileSystems::DefaultFstabOptions(partition);
	    if( contains( Partitions::fsid_dostypes, fsid ))
		{
		new_partition["mount"] =
		    "/dos/" + substring (foreign_ids, foreign_nr, 1);
		foreign_nr = foreign_nr + 1;
		}
	    else
		{
		new_partition["mount"] =
		    "/windows/" + substring (foreign_ids, foreign_nr, 1);
		foreign_nr = foreign_nr + 1;
		}
	    ChangeVolumeProperties( new_partition );
	    y2milestone( "win part %1", new_partition );
	    }
	});
    };

global define void AddMountPointsForWin( map<string,map> targets )
    ``{
    y2milestone( "AddMountPointsForWin called" );
    integer foreign_nr = 0;

    foreach(string disk, map data, targets,
	``{
	AddMountPointsForWinParts( data["partitions"]:[], true,
	                           data["max_primary"]:4, foreign_nr );
	});
    foreach(string disk, map data, targets,
	``{
	AddMountPointsForWinParts( data["partitions"]:[], false,
	                           data["max_primary"]:4, foreign_nr );
	});
    }

global void RemoveDmMapsTo( string device )
    {
    y2milestone( "RemoveDmMapsTo device:%1", device );
    InitLibstorage();
    LibStorage::StorageInterface::removeDmTableTo( sint, device );
    }

global define boolean CheckSwapable( string dev )
    {
    string cmd = "swapon " + dev;
    RemoveDmMapsTo( dev );
    boolean ok = (integer)SCR::Execute(.target.bash, cmd )==0;
    if( ok )
	{
	cmd = "swapoff " + dev;
	SCR::Execute(.target.bash, cmd );
	}
    y2milestone( "CheckSwapable dev:%1 ret:%2", dev, ok );
    return( ok );
    }

/**
 * mark swap-partitions with pseudo Mountpoint swap in targetMap
 * @param target Disk map
 * @return map<string,map> modified target
 */
global define map<string,map> AddSwapMp( map<string,map> target )
    ``{
    list swaps = SwappingPartitions();
    y2milestone( "AddSwapMp swaps %1", swaps );
    foreach(string diskdev, map disk, target,
	``{
	 disk["partitions"] = maplist(map part, disk["partitions"]:[],
	     ``{
	     if( (Stage::initial() &&
		  !Partitions::IsDosWinNtPartition(part["fsid"]:0) &&
		  part["detected_fs"]:`unknown==`swap &&
		  !part["old_swap"]:false &&
		  search( diskdev, "/dev/evms" )!=0 ) ||
		 (contains( swaps, part["device"]:"" )))
		 {
		 boolean ok = true;
		 if( !contains( swaps, part["device"]:"" ))
		     {
		     ok = CheckSwapable( part["device"]:"" );
		     y2milestone( "AddSwapMp initial ok:%1", ok );
		     }
		 if( ok )
		     {
		     part["mount"] = "swap";
		     ChangeVolumeProperties( part );
		     y2milestone( "AddSwapMp %1", part );
		     }
		 }
	     return( part );
	     });
	target[diskdev] = disk;
	});
    return( target );
    }

global define map<string,map> GetTargetMap()
    ``{
    map<string,map> tmp = $[];
    boolean changed = false;
    InitLibstorage();
    if( !probe_done && !Mode::config() )
	{
	y2milestone ("probing StorageDevices" );
	map<string,string> rename = $[];
	tmp = (map<string,map>)StorageDevices::Probe(true);
	foreach( string dev, map disk, tmp,
	    ``{
	    map dtmp = Storage::GetDiskPartitionTg( dev, $[] );
	    y2milestone( "probing dev %1 disk %2", dev, dtmp );
	    if( size(dtmp["disk"]:"")>0 && dev != dtmp["disk"]:"" )
		{
		rename[dev] = dtmp["disk"]:"";
		y2milestone( "probing rename %1", rename );
		}
	    });
	if( size(rename)>0 )
	    {
	    foreach( string old, string new, rename,
		``{
		if( haskey( tmp, old ))
		    {
		    tmp[new] = tmp[old]:$[];
		    tmp = remove( tmp, old );
		    tmp[new,"device"] = new;
		    y2milestone( "probing old:%1 new:%2", old, tmp[new]:$[] );
		    }
		});
	    }
	y2milestone ("probing done" );
	if( size(tmp)>0 )
	    {
	    probe_done = true;
	    changed = true;
	    foreach( string dev, map disk, tmp,
		``{
		disk = getDiskInfo( dev, disk );
		integer s = disk["cyl_count"]:0 * disk["cyl_size"]:0;
		disk["name"] = disk["dname"]:"" +
		   Partitions::ByteToHumanString( s ) + ", " +
		   disk["device"]:"" + ", ";
		if( size( disk["vendor"]:"")>0 )
		    disk["name"] = disk["name"]:"" + disk["vendor"]:"" + "-";
		disk["name"] = disk["name"]:"" + disk["model"]:"";
		if( haskey( disk, "dname" ))
		    disk = remove( disk, "dname" );
		tmp[dev] = disk;
		if( disk["dasdfmt"]:false )
		    Storage::InitializeDisk( dev, true );
		});
	    foreach( map c, conts,
		``{
		if( c["type"]:`CT_UNKNOWN!=`CT_DISK )
		    tmp[c["device"]:""] = getContainerInfo( c );
		});
	    StorageMap[targets_key] = tmp;
	    }
	}
    if( changed )
	{
	tmp = StorageMap[targets_key]:$[];
	SCR::Write(.target.ycp, Storage::SaveDumpPath("targetMap_i"), tmp );
	y2milestone ("AddSwapMp" );
	tmp = AddSwapMp( tmp );
	CreateTargetBackup( "initial" );
	if( Stage::initial() || Mode::repair() )
	    {
	    AddMountPointsForWin( tmp );
	    }
	StorageMap[targets_key] = GetTargetMap();
	SCR::Write(.target.ycp, Storage::SaveDumpPath("targetMap_ii"), tmp );
	y2milestone ("changed done" );
	}
    return StorageMap[targets_key]:$[];
    };

global void SetRecursiveRemoval( boolean val )
    {
    y2milestone( "SetRecursiveRemoval val:%1", val );
    LibStorage::StorageInterface::setRecursiveRemoval( sint, val );
    }

global boolean GetRecursiveRemoval()
    {
    return( LibStorage::StorageInterface::getRecursiveRemoval( sint ));
    }

global define void SetTargetMap( map<string,map> target )
    {
    y2milestone( "SetTargetMap" );
    if( !GetRecursiveRemoval() )
        SetRecursiveRemoval(true);
    //SCR::Write(.target.ycp, Storage::SaveDumpPath("targetMap_set_"+sformat("%1",count)), target );
    //count = count+1;
    CreateTargetBackup("tmp_set");
    map<string,map> tg = GetTargetMap();
    list<string> keys = maplist( string k, any e, target, ``(k));
    foreach( string k, keys,
	``{
	if( target[k,"delete"]:false && haskey( tg, k ) )
	    {
	    if( target[k,"type"]:`CT_UNKNOWN==`CT_LVM )
		{
		DeleteLvmVg( target[k,"name"]:"" );
		target[k,"delete"] = false;
		}
	    else if( target[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		{
		DeleteEvmsCo( target[k,"name"]:"" );
		target[k,"delete"] = false;
		}
	    }
	});
    keys = maplist( string k, any e, target, ``(k));
    y2milestone( "SetTargetMap keys %1", keys );
    list<string> t1 = filter( string k, keys, 
                              ``(!target[k,"delete"]:false&&
			         !target[k,"create"]:false));
    foreach( string k, t1,
	``{
	list<map> dps = filter( map p, target[k,"partitions"]:[],
	                        ``(!p["create"]:false&&!p["delete"]:false));
	if( size(dps)>0 )
	    {
	    foreach( map p, dps, 
		``{
		if( p["type"]:`primary != `extended || p["resize"]:false )
		    ChangeVolumeProperties( p );
		});
	    }
	});
    keys = maplist( string k, any e, tg, ``(k));
    keys = sort( string a, string b, keys,
                 ``( type_order[tg[a,"type"]:`CT_UNKNOWN]:6 >
		     type_order[tg[b,"type"]:`CT_UNKNOWN]:6 ));
    y2milestone( "SetTargetMap keys %1", keys );
    foreach( string k, keys,
	``{
	list<map> dps = filter( map p, tg[k,"partitions"]:[],
	                        ``(p["create"]:false));
	if( size(dps)>1 && haskey( dps[0]:$[], "nr" ))
	    {
	    dps = sort( map a, map b, dps, ``(a["nr"]:0>b["nr"]:0));
	    y2milestone( "SetTargetMap dps:%1", dps );
	    }
	foreach( map p, dps, ``{DeleteDevice( k, p["device"]:"" );});
	if( tg[k,"create"]:false )
	    {
	    if( tg[k,"type"]:`CT_UNKNOWN==`CT_LVM )
		DeleteLvmVg( tg[k,"name"]:"" );
	    else if( tg[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		DeleteEvmsCo( tg[k,"name"]:"" );
	    }
	else if( !tg[k,"delete"]:false )
	    {
	    if( tg[k,"type"]:`CT_UNKNOWN==`CT_LVM &&
		size(target[k,"devices_add"]:[])>0 )
		{
		list<string> ls = target[k,"devices_add"]:[];
		foreach( string d, ls,
			 ``{Storage::ReduceLvmVg( target[k,"name"]:"", d );});
		}
	    else if( tg[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		{
		list<string> ls = target[k,"devices_add"]:[];
		foreach( string d, ls,
			 ``{Storage::ReduceEvmsCo( target[k,"name"]:"", d );});
		}
	    }
	});
    keys = maplist( string k, any e, target, ``(k));
    keys = sort( string a, string b, keys,
                 ``( type_order[target[a,"type"]:`CT_UNKNOWN]:6 >
		     type_order[target[b,"type"]:`CT_UNKNOWN]:6 ));
    y2milestone( "SetTargetMap keys %1", keys );
    foreach( string k, keys,
	``{
	list<map> dps = filter( map p, target[k,"partitions"]:[],
	                        ``(p["delete"]:false));
	if( size(dps)>1 && haskey( dps[0]:$[], "nr" ))
	    {
	    dps = sort( map a, map b, dps, ``(a["nr"]:0>b["nr"]:0));
	    }
	foreach( map p, dps, 
	    ``{
	    if( size(p["dtxt"]:"")>0 )
		ChangeDescText( p["device"]:"", p["dtxt"]:"" );
	    DeleteDevice( k, p["device"]:"" );
	    });
	if( target[k,"delete"]:false )
	    {
	    if( target[k,"type"]:`CT_UNKNOWN==`CT_LVM )
		DeleteLvmVg( target[k,"name"]:"" );
	    else if( target[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		DeleteEvmsCo( target[k,"name"]:"" );
	    else if( target[k,"type"]:`CT_UNKNOWN==`CT_DISK )
		DeletePartitionTable( k, target[k,"size_k"]:0 );
	    }
	});
    keys = maplist( string k, any e, target, ``(k));
    keys = sort( string a, string b, keys,
                 ``( type_order[target[a,"type"]:`CT_UNKNOWN]:6 <
		     type_order[target[b,"type"]:`CT_UNKNOWN]:6 ));
    y2milestone( "SetTargetMap keys %1", keys );
    foreach( string k, keys,
	``{
	if( target[k,"create"]:false )
	    {
	    if( target[k,"type"]:`CT_UNKNOWN==`CT_LVM )
		{
		CreateLvmVg( target[k,"name"]:"", target[k,"pesize"]:0,
		             target[k,"lvm2"]:true );
		list<string> ls =
		    (list<string>)union( target[k,"devices"]:[],
				         target[k,"devices_add"]:[] );
		foreach( string d, ls,
			 ``{Storage::ExtendLvmVg( target[k,"name"]:"", d );});
		}
	    else if( target[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		{
		CreateEvmsCo( target[k,"name"]:"", target[k,"pesize"]:0,
		              target[k,"lvm2"]:true );
		list<string> ls =
		    (list<string>)union( target[k,"devices"]:[],
				         target[k,"devices_add"]:[] );
		foreach( string d, ls,
			 ``{Storage::ExtendEvmsCo( target[k,"name"]:"", d );});
		}
	    }
	if( !target[k,"delete"]:false && !target[k,"create"]:false )
	    {
	    if( target[k,"type"]:`CT_UNKNOWN==`CT_LVM && 
	        size(target[k,"devices_add"]:[])>0 )
		{
		list<string> ls = target[k,"devices_add"]:[];
		foreach( string d, ls,
			 ``{Storage::ExtendLvmVg( target[k,"name"]:"", d );});
		}
	    else if( target[k,"type"]:`CT_UNKNOWN==`CT_EVMS &&
	        size(target[k,"devices_add"]:[])>0 )
		{
		list<string> ls = target[k,"devices_add"]:[];
		foreach( string d, ls,
			 ``{Storage::ExtendEvmsCo( target[k,"name"]:"", d );});
		}
	    }
	list<map> dps = filter( map p, target[k,"partitions"]:[],
	                        ``(!p["delete"]:false&&p["create"]:false) );
	if( size(dps)>1 && haskey( dps[0]:$[], "nr" ))
	    dps = sort( map a, map b, dps, ``(a["nr"]:0<b["nr"]:0));
	foreach( map p, dps,
	    ``{
	    CreateAny( target[k,"type"]:`CT_UNKNOWN, target[k]:$[], p );
	    if( p["type"]:`primary != `extended )
		ChangeVolumeProperties( p );
	    });
	});
    boolean changed = !EqualBackupStates( "tmp_set", "", true );
    y2milestone( "SetTargetMap changed:%1", changed );
    if( changed )
	UpdateChangeTime();
    DisposeTargetBackup("tmp_set");
    y2milestone( "SetTargetMap ChangeTime %1", GetTargetChangeTime() );
    };

global define map<string,map> ReReadTargetMap()
    ``{
    y2milestone("start reread sint:%1", sint );
    probe_done = false;
    if( sint == nil )
	InitLibstorage();
    else
	LibStorage::StorageInterface::rescanEverything( sint );
    conts = getContainers();
    return GetTargetMap();
    };

global integer CommitChanges()
    {
    y2milestone( "CommitChanges" );
    integer ret = LibStorage::StorageInterface::commit( sint );
    if( ret<0 )
	y2error( "CommitChanges sint ret:%1", ret );
    ClassifiedSettings = $[];
    return( ret );
    }

global string DeviceMounted( string dev )
    {
    string ret = "";
    LibStorage::StorageInterface::checkDeviceMounted( sint, dev, ret );
    if( size(ret)>0 )
	y2milestone( "DeviceMounted %1 at %2", dev, ret );
    return( ret );
    }

global boolean Umount( string dev )
    {
    boolean ret = LibStorage::StorageInterface::umountDevice( sint, dev );
    y2milestone( "Umount %1 ret %2", dev, ret );
    return( ret );
    }

global boolean Mount( string dev, string mp )
    {
    boolean ret = LibStorage::StorageInterface::mountDevice( sint, dev, mp );
    y2milestone( "Mount %1 to %2 ret %3", dev, mp, ret );
    return( ret );
    }

global list ReadFstab( string dir )
    {
    list ret = [];
    list<any> vinfos = [];
    boolean r = LibStorage::StorageInterface::readFstab( sint, dir, vinfos );
    if( !r )
	y2error( "ReadFstab sint dir %1 ret %2", dir, r );
    else
	{
	foreach( any info, vinfos,
	    ``{
	    map p = $[];
	    p = volumeMap( info, p );
	    ret = add( ret, p );
	    });
	}
    y2milestone( "ReadFstab from %1 ret %2", dir, ret );
    return( ret );
    }

global list<map> mountedPartitionsOnDisk( string disk )
    {
    map<string,any> d = GetDisk( GetTargetMap(), disk );
    list<map> ret = filter( map p, d["partitions"]:[],
                            ``(size(DeviceMounted(p["device"]:""))>0));
    return( ret );
    }

string save_chtxt = "";

global string ChangeText()
    {
    list<string> l = LibStorage::StorageInterface::getCommitActions( sint, true );
    string ret = "";
    if( size(l)>0 )
	ret = HTML::List( l );
    if( ret != save_chtxt )
	{
	foreach( string s, l,
	    ``{
	    y2milestone( "ChangeText %1", s );
	    });
	save_chtxt = ret;
	}
    return( ret );
    }

global string LastAction()
    {
    string ret = LibStorage::StorageInterface::getLastAction( sint );
    return( ret );
    }

global string ExtendedErrorMsg()
    {
    string ret = LibStorage::StorageInterface::getExtendedErrorMessage( sint );
    return( ret );
    }

global void SetZeroNewPartitions( boolean val )
    {
    y2milestone( "SetZeroNewPartitions val:%1", val );
    LibStorage::StorageInterface::setZeroNewPartitions( sint, val );
    }

/* GetMountPoints()
 * collect mountpoint:device as map to get a sorted list
 * @returns: map of lists, the map key is the mount point,
 *		usually starting with a "/". Exception is "swap"
 *	For directory mount points (key starting with /) the value
 *  is a list [partitionName, fsid, targetdevice, raid_type]
 *  For swap mount points, the value is a list of lists:
 *  [[partitionName, fsid, targetdevice, raid_type], ...]
 *
 */
global define map GetMountPoints()
    ``{
    map mountPoints = $[];
    list swapPoints = [];
    map<string,map> tg = GetTargetMap();
    foreach ( string targetdevice, map target, tg,
	``{
	list<map> partitions = target["partitions"]:[];
	foreach (map partition, partitions,
	    ``{
	    string partitionName = partition["device"]:"";
	    string mountPoint = partition["mount"]:"";
	    integer fsid = partition["fsid"]:0;
	    if (mountPoint != "")
		{
		string raid_type = "";
		if( partition["type"]:`undefined == `sw_raid )
		    {
		    raid_type = partition["raid_type"]:"";
		    }
		// partition has a mount point
		if (mountPoint == "swap")
		    {
		    swapPoints = add( swapPoints,
				      [partitionName, fsid, targetdevice, raid_type]);
		    }
		else
		    {
		    mountPoints = add( mountPoints, mountPoint,
		                       [partitionName, fsid, targetdevice, raid_type]);
		    }
		}
	    });
	});
    if (size (swapPoints) > 0)
	mountPoints = add (mountPoints, "swap", swapPoints);
    if( !Stage::initial () )
	{
	list<map> cm = filter(map e, Partitions::CurMounted(),
			      ``(search(e["spec"]:"","/dev/")==0));
	foreach(map e, cm,
	    ``{
	    if( !haskey( mountPoints, e["file"]:"" ) )
		{
		map p = GetPartition( tg, e["spec"]:"" );
		if( size(p)>0 )
		    {
		    string raid_type = "";
		    if( p["type"]:`undefined == `sw_raid )
			{
			raid_type = p["raid_type"]:"";
			}
		    map d = GetDiskPartition( e["spec"]:"" );
		    mountPoints[e["file"]:""] =
			[ p["device"]:"", p["fsid"]:0, d["disk"]:"", raid_type ];
		    }
		}
	    });
	}
    y2milestone( "ret %1", mountPoints );
    return mountPoints;
    }

global define string
GetIdSmaller( string disk, integer delim )
    ``{
    string ret = disk;
    map<string,map> tg = GetTargetMap();
    if( haskey( tg[disk,"partitions",0]:$[], "nr" ))
	{
	list<map> ps = filter( map p, tg[disk,"partitions"]:[], ``(p["nr"]:0<delim));
	if( size(ps)>1 )
	    ps = sort( map a, map b, ps, ``(a["nr"]:0>b["nr"]:0));
	if( size(ps)>0 )
	    ret = ps[0,"device"]:"";
	}
    else 
	ret = tg[disk,"partitions",0,"device"]:disk;
    y2milestone( "GetIdSmaller disk:%1 delim:%2 ret:%3",
                 disk, delim, ret );
    return( ret );
    }


/* set <key> in partition <device> to the given <value> and return changed map <tg> */
global define map<string,map> SetPartitionData( map<string,map> tg,
                                                string device, string key,
						any value )
    ``{
    y2milestone( "SetPartitionData device=%1 key=%2 value=%3", device, key,
                 value );
    map tmp = GetDiskPartitionTg( device, tg );
    string disk = tmp["disk"]:"";
    string dev = GetDeviceName( tmp["disk"]:"", tmp["nr"]:(any)0 );
    list r_part = filter(map part, tg[disk,"partitions"]:[],
			  ``(part["device"]:"" != dev ));
    if( size(r_part)!=size(tg[disk,"partitions"]:[]) )
	{
	map p = filter( map part, tg[disk,"partitions"]:[],
		        ``(part["device"]:"" == dev ))[0]:$[];
	if( size(p)>0 )
	    {
	    p[key] = value;
	    r_part    = add( r_part, p );
	    tg[disk,"partitions"] = r_part;
	    }
	}
    return( tg );
    }

/* remove <key> in partition <device> and return changed map <tg> */
global define map<string,map> DelPartitionData( map<string,map> tg,
                                                string device, string key)
    ``{
    y2debug( "device=%1, key=%2", device, key );
    map tmp = GetDiskPartitionTg( device, tg );
    string disk = tmp["disk"]:"";
    string dev = GetDeviceName( tmp["disk"]:"", tmp["nr"]:(any)0 );
    list r_part = filter(map part, tg[disk,"partitions"]:[],
			  ``(part["device"]:"" != dev ));
    if( size(r_part)!=size(tg[disk,"partitions"]:[]) )
	{
	map p = filter( map part, tg[disk,"partitions"]:[],
			``(part["device"]:"" == dev ))[0]:$[];
	if( size(p)>0 )
	    {
	    p = filter(string k, any e, (map<string,any>)p, ``(k != key) );
	    r_part    = add( r_part, p );
	    tg[disk,"partitions"] = r_part;
	    }
	}
    return( tg );
    }





    /* maindevkey = all | maindevkey
       what = "all"		|
              "assigned_raid"	| "assigned_vg"  | "not_assigned" | "assigned"
	      "delete" | "no_delete"
	      "edit_possible"	| "delete_possible" |
	      "display_possible" |
	      "assign_raid_possible" | "assign_vg_possible"
	      "no_virtal" 	| "virtual"
      how = "all"	| "key_list"  | "index_list" (   raid_lib -> get_possible_rds  )
    */




/* Contain the current key ( subdevkey ) for all wizards */
string WizardKey = "";

global define string GetWizardKey()
    ``{
	y2debug( " Return wizard key %1", WizardKey);
	return WizardKey;
    };

global define void SetWizardKey( string key )
    ``{
    y2debug(" Set WizardKey %1", WizardKey);
    WizardKey = key;
    };


    /* Functions for testing */

    global define void DebugStorage()``{

	y2milestone("StorageMaps: %1",StorageMaps);
	y2milestone("Storage:%1",StorageMap);
    }


/**
 * Check if a disk is a real disk and not RAID or LVM
 * @return boolean true if real disk
 */
global define boolean IsRealDisk( map entry )
    ``{
    return( entry["type"]:`CT_UNKNOWN==`CT_DISK &&
            !(entry["type"]:`CT_UNKNOWN==`CT_DISK && entry["readonly"]:false &&
	      entry["driver"]:""=="vbd") );
    }

global define boolean DeviceRealDisk( string device )
    ``{
    boolean ret = false;

    if( search( device, "LABEL" )!=0 && search( device, "UUID" )!=0 )
	{
	map dev = $[];
	dev = GetDiskPartition( device );
	ret = dev["disk"]:"" != "/dev/md" && dev["disk"]:"" != "/dev/loop" &&
	      search( dev["disk"]:"", "/dev/evms")!=0 &&
	      is( dev["nr"]:(any)0, integer );
	if( !ret )
	    {
	    map st = (map)SCR::Read( .target.stat, dev["disk"]:"" );
	    ret = !st["isdir"]:false;
	    }
	}
    y2milestone( "DeviceRealDisk %1 ret %2", device, ret );
    return ret;
    }

/**
  * Determine if there is any Linux partition on this system.
  *
  * If there is none, we don't need to ask if the user wants to update or
  * boot an installed system - he can only do a new installation anyway.
  * No time-consuming or dangerous operations should be performed here,
  * only simple checks for existence of a Linux (type 83) partition.
  *
  * @return boolean true if there is anything that might be a Linux partition
  **/
global define boolean HaveLinuxPartitions() ``{
    boolean ret = false;
    foreach ( string dev, map disk, GetTargetMap(), ``{
        if( !ret )
	    {
	    if( IsRealDisk( disk ) )
		{
		foreach( map e, disk["partitions"]:[], ``{
		    ret = ret ||
			  Partitions::IsLinuxPartition( e["fsid"]:Partitions::fsid_native );
		    });
		}
	    }
	});
    y2milestone( "HaveLinuxPartitions ret=%1", ret );
    return( ret );
    };

/**
 * Get list of all Partitions on all real disks
 * @return list Partition list
 */
global define list GetPartitionList()``{
    list ret = [];
    foreach ( string dev, map disk, GetTargetMap(), ``{
        if( IsRealDisk( disk ) )
	    {
	    list<map> l = disk["partitions"]:[];
	    ret = union( ret, maplist( map p, l, ``(p["device"]:"")));
	    }
	});
    ret = sort( ret );
    y2debug( "GetPartitionList ret=%1", ret );
    return( ret );
    }

/**
 * Get list of all Linux Partitions on all real disks
 * @return list Partition list
 */
global define list GetOtherLinuxPartitions()``{
    list ret = [];
    foreach ( string dev, map disk, GetTargetMap(), ``{
        if( IsRealDisk( disk ) )
	    {
	    list<map> l = (list<map>) filter( map p, disk["partitions"]:[],
	                     ``(!p["format"]:false &&
			        Partitions::IsLinuxPartition(p["fsid"]:0)) );
	    l = filter(map p, l, ``(contains( [`xfs, `ext2, `ext3, `jfs, `reiser],
	                                    p["used_fs"]:`unknown)));
	    l = filter(map p, l,
			``(!FileSystems::IsSystemMp( p["mount"]:"", false )));
	    if( size(l)>0 )
		{
		ret = union( ret, l );
		}
	    }
	});
    y2milestone( "GetOtherLinuxPartitions ret=%1", ret );
    return( ret );
    }

/**
 * Check if swap paritition is availbe on a disk
 * @param disk Disk to be checked
 * @return boolean true if swap available.
 */
global define boolean CheckSwapOn( string disk )``{
    boolean ret = false;
    list swaps = SwappingPartitions();
    while( size(swaps)>0 && !ret )
	{
	if( search( swaps[0]:"", disk )==0)
	    {
	    ret = true;
	    }
	swaps = remove( swaps, 0 );
	}
    y2milestone( "CheckSwapOn %1 ret %2", disk, ret );
    return( ret );
    }

global define string CheckSwapConflicts()``{
    string ret = "";
    list swaps = SwappingPartitions();
    if( size(swaps)>0 )
	{
	list plist = [];
	foreach ( string dev, map disk, GetTargetMap(), ``{
	    if( IsRealDisk( disk ) )
		{
		list<map> l = disk["partitions"]:[];
		l = filter(map p, l, ``(size(p["mount"]:"")>0 ||
				        p["used_by_type"]:`UB_NONE != `UB_NONE ));
		l = filter(map p, l, ``(p["mount"]:"" != "swap") );
		list l1 = maplist(map p, l, ``(p["device"]:""));
		plist = union( plist, l1 );
		}
	    });
	y2milestone( "CheckSwapConflicts used %1", plist );
	while( size(swaps)>0 && size(ret)==0 )
	    {
	    if( contains( plist, swaps[0]:"" ) )
		{
		ret = swaps[0]:"";
		}
	    swaps = remove( swaps, 0 );
	    }
	}
    y2milestone( "CheckSwapConflicts ret %1", ret );
    return( ret );
    }

global define list GetPrimPartitions( map<string,map> targets,
                                      boolean foreign_os )
    ``{
    list<map> ret = [];
    map entry = $[];
    string text = "";
    integer num_dos = 0;
    integer num_win = 0;
    integer num_os2 = 0;
    integer num_linux = 0;
    string linux_text = "Linux other";
    string dos_text = "dos";
    string win_text = "windows";
    string os2_text = "OS/2 Boot Manager";

    foreach(string disk, map data, targets,
	``{
	foreach(map part, data["partitions"]:[],
	    ``{
	    string device = part["device"]:"";
	    if( part["type"]:`unknown == `primary &&
	        SCR::Execute (.target.bash,
		              "/usr/lib/YaST2/bin/check.boot "+device) == 0)
		{
		text = "";
	        if( Partitions::IsDosWinNtPartition( part["fsid"]:0 ) &&
		    GetFreeSpace( device, 0, part["used_fs"]:`none, false )["win_disk"]:false )
		    {
		    if( contains( Partitions::fsid_dostypes, part["fsid"]:0 ) )
			{
			num_dos = num_dos+1;
			text = dos_text;
			}
		    else
			{
			num_win = num_win+1;
			text = win_text;
			}
		    }
		else if( part["fsid"]:0 == 0x12 && !foreign_os )
		    {
		    text = "Vendor diagnostic";
		    }
		else if( part["fsid"]:0 == 0x0a )
		    {
		    text = os2_text;
		    num_os2 = num_os2+1;
		    }
		else if( part["fsid"]:0 == Partitions::fsid_native &&
		         size(part["mount"]:"")==0 && !foreign_os )
		    {
		    text = linux_text;
		    num_linux = num_linux+1;
		    }
		if( size(text)>0 )
		    {
		    entry["device"] = device;
		    entry["string"] = text;
		    ret = add( ret, eval(entry) );
		    y2milestone( "new entry %1", entry );
		    }
		}
	    });
	});
    y2milestone( "GetPrimPartitions foreign_os:%5 num_linux %1 num_win %2 num_dos %3 num_os2 %4",
                 num_linux, num_win, num_dos, num_os2, foreign_os );
    integer num = 1;
    if( num_linux>1 )
	{
	ret = maplist( map entry, ret,
	    ``{
	    if( entry["string"]:""==linux_text )
		{
		entry["string"] = linux_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    num = 1;
    if( num_dos>1 )
	{
	ret = maplist( map entry, ret,
	    ``{
	    if( entry["string"]:""==dos_text )
		{
		entry["string"] = dos_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    num = 1;
    if( num_win>1 )
	{
	ret = maplist( map entry, ret,
	    ``{
	    if( entry["string"]:""==win_text )
		{
		entry["string"] = win_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    num = 1;
    if( num_os2>1 )
	{
	ret = maplist( map entry, ret,
	    ``{
	    if( entry["string"]:""==os2_text )
		{
		entry["string"] = os2_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    y2milestone( "GetPrimPartitions ret %1", ret );
    return( ret );
    }

global define list GetWinPrimPartitions( map<string,map> targets )
    ``{
    list ret = GetPrimPartitions( targets, true );
    y2milestone( "GetWinPrimPartitions ret %1", ret );
    return( ret );
    }

global define list<string> AddPackageList()
    ``{
    list<string> pl = hw_packages;
    boolean mount_lvm = false;
    boolean need_evms = false;
    map<string,map> tg = GetTargetMap();
    map<string,map> tt = filter( string k, map e, tg,
                                 ``(e["type"]:`CT_UNKNOWN==`CT_LVM ));
    boolean have_lvm = size(tt)>0;
    if( have_lvm )
	{
	list<map> part = [];
	foreach( string k, map e, tt,
		 ``{
		 part = (list<map>)merge( part, e["partitions"]:[]);
		 });
	mount_lvm = size(filter( map p, part, ``(size(p["mount"]:"")>0)))>0;
	}
    tt = filter( string k, map e, tg, ``(k=="/dev/evms"||search(k, "/dev/evms/")==0));
    if( size(filter( string k, map e, tg, ``(e["is_container"]:false &&
					     search(e["name"]:"","lvm/")!=0 &&
					     search(e["name"]:"","lvm2/")!=0)))>0)
	{
	y2milestone( "non lvm evms container" );
	need_evms = true;
	}
    if( !need_evms )
	{
	list<map> part = [];
	foreach( string k, map e, tt,
		 ``{
		 part = (list<map>)merge( part, e["partitions"]:[]);
		 });
	need_evms = size(filter( map p, part, ``(size(p["mount"]:"")>0)))>0;
	}
    y2milestone( "AddPackageList have_lvm %1 mount_lvm %2 need_evms %3",
                  have_lvm, mount_lvm, need_evms );
    if( have_lvm && (mount_lvm||!need_evms))
	{
	pl = add( pl, "lvm2" );
	}
    if( need_evms )
	{
	pl = add( pl, "evms" );
	pl = add( pl, "yast2-storage-evms" );
	}
    y2milestone( "AddPackageList ret %1", pl );
    return( pl );
    }

global define list GetForeignPrimary()
    ``{
    list ret = [];
    if( Arch::i386 () || Arch::ia64 () || Arch::x86_64 () )
	{
	foreach(map e, (list<map>)GetPrimPartitions( GetTargetMap(), false ),
	    ``{
	    ret = add( ret, sformat( "%1 %2", e["device"]:"", e["string"]:"" ));
	    });
	}
    y2milestone( "ret=%1", ret );
    return( ret );
    }

global define map IsResizable( map part )
    ``{
    map ret = FileSystems::IsResizable(`unknown);
    if( !Arch::s390 () &&
        (part["type"]:`none==`lvm || Partitions::IsResizable( part["fsid"]:0 )))
	{
	if( part["fsid"]:0==Partitions::fsid_swap )
	    {
	    ret = FileSystems::IsResizable(`swap);
	    }
	else
	    {
	    ret = FileSystems::IsResizable(part["used_fs"]:`unknown);
	    }
	}
    y2milestone( "IsResizable part:%1 ret:%2", part, ret );
    return( ret );
    }

global define integer FreeCylAfter( map disk, map partition )
    ``{
    integer ret = 0;
    integer next_used_cyl = disk["cyl_count"]:0;
    integer cylinder = partition["region",0]:0;
    if( haskey( partition, "orig_size_k" ))
	{
        cylinder = cylinder + partition["orig_size_k"]:0*1024/disk["cyl_size"]:1;
        }
    else
	{
        cylinder = cylinder + partition["region",1]:0;
        }
    if( partition["type"]:`primary == `logical )
	{
	map ext = filter( map part, disk["partitions"]:[],
			  ``( part["type"]:`primary==`extended ))[0]:$[];
	next_used_cyl = ext["region",0]:0+ext["region",1]:0;
	}
    if( cylinder < next_used_cyl )
	{
	foreach(map part, disk["partitions"]:[], ``{
	    integer start = part["region",0]:0;
	    if( start >= cylinder && start < next_used_cyl )
		{
		next_used_cyl = start;
		}
	    });
	}
    if( next_used_cyl >= cylinder )
	ret = next_used_cyl-cylinder;
    y2milestone( "FreeCylAfter cyl:%1 ret:%2", cylinder, ret );
    return( ret );
    }

global define boolean CheckNextCreated( map disk, list region )
    ``{
    boolean ret = false;
    integer cylinder = region[0]:0 + region[1]:0;
    foreach(map part, disk["partitions"]:[], ``{
	if( part["region",0]:0 == cylinder && part["create"]:false )
	    {
	    ret = true;
	    }
	});
    y2milestone( "CheckNextCreated region:%1 ret:%2", region, ret );
    return( ret );
    }

global define string PathToDestdir( string pt )
    ``{
    if( Installation::scr_destdir != "/" )
	{
	pt = Installation::scr_destdir + pt;
	}
    return( pt );
    }

//-----------------------------------------------------
//
// change an entry in /etc/fstab
//
global define void ChangeLineFstab( map entry )
    ``{
    string tabpath = PathToDestdir( "/etc/fstab" );
    if( Installation::scr_destdir != "/" )
	{
	if( SCR::Read( .target.size, tabpath )>= 0 )
	    SCR::Execute( .target.remove, tabpath );
	}
    map fstab = Partitions::GetFstab( tabpath );
    list lines = Storage::FindFstabLines( fstab, entry["mount"]:"",
                                          entry["spec"]:"", "x", "x" );
    list fstlist = [ entry["spec"]:"", entry["mount"]:"",
		     entry["vfstype"]:"", entry["mntops"]:"",
		     sformat("%1",entry["freq"]:0),
		     sformat("%1",entry["passno"]:0) ];
    y2milestone( "lines %1", lines );
    if( size(lines)==0 )
	{
	AsciiFile::AppendLine( fstab, fstlist );
	}
    else
	{
	integer field = 0;
	while( field<4 )
	    {
	    AsciiFile::ChangeLineField( fstab, lines[0]:-1, field,
					fstlist[field]:"" );
	    field = field+1;
	    }
	}
    string dir = entry["mount"]:"";
    if( substring( dir, 0, 1 )== "/" )
	{
	dir = PathToDestdir( dir );
	if( SCR::Read( .target.size, dir )<=0 )
	    {
	    SCR::Execute( .target.mkdir, dir );
	    }
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    };

global define map MakeCdromFstabEntry( map cd )
    ``{
    map entry = FileSystems::GetFstabDefaultMap( "cdrom" );
    string cdmount = cd["linkname"]:"";
    entry["spec"] = cdmount;
    entry["mount"] = "/media/"+substring(cdmount,5);
    string enc = FileSystems::LangTypicalEncoding();
    if( !contains( [ "iso8859-1", "iso8859-15", "" ], enc ))
	{
	entry["mntops"] = entry["mntops"]:"" + ",iocharset=" + enc;
	}
    y2milestone( "ret %1", entry );
    return( entry );
    };

define void HandleModulesOnBoot( map<string,map> targetMap )
    ``{
    list<string> ml = filter( string e,
                              (list<string>) splitstring( Misc::SysconfigRead( .sysconfig.kernel.MODULES_LOADED_ON_BOOT, "" ), " \t"),
			      ``(size(e)>0));
    y2milestone( "HandleModulesOnBoot ml %1", ml );
    boolean need_cryptoloop = false;
    boolean need_fish2 = false;
    foreach( string disk, map e, targetMap,
	``{
	foreach( map p, e["partitions"]:[],
	    ``{
	    if( p["noauto"]:false && p["enc_type"]:`none!=`none )
		{
		if( p["enc_type"]:`none == `twofish )
		    need_cryptoloop = true;
		else if( p["enc_type"]:`none == `twofish_old ||
		         p["enc_type"]:`none == `twofish_256_old )
		    need_fish2 = true;
		}
	    });
	});
    y2milestone( "HandleModulesOnBoot need_fish2 %1 need_cryptoloop %2", need_fish2,
                 need_cryptoloop );
    if( need_fish2 && find( string e, ml, ``(e=="loop_fish2"))==nil )
	{
	ml = add( ml, "loop_fish2" );
	SCR::Write( .sysconfig.kernel.MODULES_LOADED_ON_BOOT,
		    mergestring( ml, " " ) );

	}
    if( need_cryptoloop && find( string e, ml, ``(e=="cryptoloop"))==nil )
	{
	ml = add( ml, "cryptoloop" );
	SCR::Write( .sysconfig.kernel.MODULES_LOADED_ON_BOOT,
		    mergestring( ml, " " ) );
	}
    if( need_cryptoloop && find( string e, ml, ``(e=="twofish"))==nil )
	{
	ml = add( ml, "twofish" );
	SCR::Write( .sysconfig.kernel.MODULES_LOADED_ON_BOOT,
		    mergestring( ml, " " ) );

	}
    }

global define integer AddFstabEntry( map e )
    {
    y2milestone( "AddFstabEntry entry:%1", e );
    integer ret = 0;
    integer freq = e["freq"]:0;
    integer passno = e["passno"]:0;
    string dev = e["spec"]:"";
    string m = e["mount"]:"";
    string vfs = e["vfstype"]:"auto";
    string opts = e["mntops"]:"defaults";
    ret = LibStorage::StorageInterface::addFstabEntry( sint, dev, m, vfs, opts,
						       freq, passno );
    if( ret<0 )
	y2error( "ret:%1 entry:%2", ret, e );
    return( ret );
    }

global define void ActivateHld( boolean val )
    {
    y2milestone( "ActivateHld val:%1", val );
    LibStorage::StorageInterface::activateHld( sint, val );
    }

global define void SetMdOn( boolean on )
    {
    y2milestone( "SetMdOn on %1", on );
    ActivateHld( on );
    y2milestone( "return" );
    }

void UpdateBootFstabEvms()
    {
    string tabpath = PathToDestdir( "/etc/fstab" );
    y2milestone( "UpdateBootFstabEvms %1", 
                 SCR::Execute( .target.bash_output, "grep /boot " + tabpath ));
    map fstab = Partitions::GetFstab( tabpath );
    list lines = AsciiFile::FindLineField( fstab, 1, Partitions::BootMount() );
    y2milestone( "UpdateBootFstabEvms lines %1", lines );
    map l = AsciiFile::GetLine( fstab, lines[0]:-1 );
    if( search( l["fields",0]:"", "/dev/evms" )!=0 )
	{
	map<string,map> tg = filter( string k, map e, GetTargetMap(), 
	                             ``(IsRealDisk( e )) );
	map p = GetPartition( tg, l["fields",0]:"" );
	y2milestone( "UpdateBootFstabEvms p %1", p );
	if( size(p)>0 )
	    {
	    AsciiFile::ChangeLineField( fstab, lines[0]:-1, 0, 
					"/dev/evms/"+substring(p["device"]:"",5));
	    AsciiFile::RewriteFile( fstab, tabpath );
	    }
	}
    y2milestone( "UpdateBootFstabEvms %1", 
                 SCR::Execute( .target.bash_output, "grep /boot " + tabpath ));
    }

global define boolean BootEvms();

global define void WriteFstab()
    ``{
    y2milestone( "WriteFstab called" );
    StorageDevices::MakeCDLinks();
    Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "proc" ) );
    Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "sys" ) );
    Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "debug" ) );
    if( Hotplug::haveUSB )
	Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "usb" ) );
    Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "pts" ) );

    map m = $[];
    integer num = 0;
    
    foreach( string tdevice, any tdata, StorageDevices::ZipDrives,
	``{
	m = FileSystems::GetFstabDefaultMap( "zip" );
	string zfile = "/zip";
	if( num > 0 )
	    zfile = zfile + sformat( "%1", num );
	m["mount"] = "/media"+zfile;
	m["spec"] = tdevice+"4";
	Storage::AddFstabEntry( m );
	num = num+1;
	});
    num = 0;
    foreach( map drive, StorageDevices::FloppyDrives,
	``{
	m = FileSystems::GetFstabDefaultMap( "floppy" );
	string fdname = "/floppy";
	if( num > 0 )
	    fdname = fdname + sformat( "%1", num );
	m["mount"] = "/media"+fdname;
	m["spec"] = drive["dev_name"]:"";
	Storage::AddFstabEntry( m );
	num = num+1;
	});
    if( BootEvms() )
	UpdateBootFstabEvms();
    HandleModulesOnBoot( GetTargetMap() );
    }

global define map<string,map> SpecialBootHandling( map<string,map> tg )
    ``{
    boolean have_ppc_boot = false;
    foreach( string dev, map disk, tg,
	``{
	foreach(map part, disk["partitions"]:[],
	    ``{
	    if( !have_ppc_boot &&
	        part["fsid"]:0 == Partitions::fsid_prep_chrp_boot &&
		size(part["mount"]:"")==0 && part["create"]:false )
		{
		have_ppc_boot = true;
		}
	    });
	});
    y2milestone( "SpecialBootHandling: have_ppc_boot:%1", have_ppc_boot );
    foreach( string dev, map disk, tg,
	``{
	list new_part = [];
	foreach(map part, disk["partitions"]:[],
	    ``{
	    // convert a mount point of /boot to a 41 PReP boot partition
	    if( Partitions::PrepBoot() &&
		part["mount"]:"" == Partitions::BootMount() && !have_ppc_boot )
		{
		integer id = Partitions::fsid_prep_chrp_boot;
		part["format"] = false;
		part["mount"] = "";
		part["fstype"] = Partitions::FsIdToString( id );
		part["prep_install"] = true;
		if( !part["create"]:false && part["fsid"]:0 != id )
		    {
		    part["ori_fsid"] = part["fsid"]:0;
		    part["change_fsid"] = true;
		    }
		part["fsid"] = id;
		y2milestone( "SpecialBootHandling modified Prep part=%1", part );
		}
	    if( Arch::board_mac () &&
		part["mount"]:"" == Partitions::BootMount() )
		{
		integer id = Partitions::fsid_mac_hfs;
		part["mount"] = "";
		part["fstype"] = Partitions::FsIdToString( id );
		part["fsid"] = id;
		part["used_fs"] = `hfs;
		part["detected_fs"] = `hfs;
		y2milestone( "SpecialBootHandling modified hfs part=%1", part );
		}
	    if( Arch::ia64 () &&
		part["mount"]:"" == Partitions::BootMount() )
		{
		integer id = Partitions::fsid_gpt_boot;
		part["fsid"] = id;
		part["fstype"] = Partitions::FsIdToString( id );
		if( !part["create"]:false && part["detected_fs"]:`none==`vfat )
		    {
		    part["format"] = false;
		    }
		y2milestone( "SpecialBootHandling modified GPT boot part=%1", part );
		}
	    new_part = add( new_part, part );
	    });
	tg[dev,"partitions"] = new_part;
	});
    return( tg );
    }

global define list<list<string> > AutodetectMultipathRaid( map<string,map> tg )
    ``{
    list<list<string> > ret = [];
    map<string, list> disks = (map<string, list>) $[];
    foreach(string dev, map disk, tg,
	``{
	string id = disk["unique"]:"";
	integer pos = search( id, "." );
	if( pos != nil )
	    {
	    id = substring( id, pos+1 );
	    if( haskey( disks, id ) )
		{
		disks[id] = add( disks[id]:[], dev );
		}
	    else
		{
		disks[id] = [ dev ];
		}
	    }
	});
    disks = (map<string, list>) filter(string key, list entry, disks, ``(size(entry)>=2) );
    y2milestone( "disks %1", disks );
    foreach( string key, list entry, disks,
	``{
	foreach(map p, tg[entry[0]:"","partitions"]:[],
	    ``{
	    boolean ok = true;
	    list<string> dl = [];
	    foreach(string disk, (list<string>)entry,
		``{
		string dev = p["device"]:"";
		map p1 = GetPartition( tg, dev );
		if( p1["type"]:`primary == `extended ||
		    p1["used_by_type"]:`UB_NONE!=`UB_NONE ||
		    size(p1["mount"]:"")>0 )
		    {
		    ok = false;
		    }
		dl = add( dl, dev );
		});
	    if( ok )
		{
		ret = add( ret, dl );
		}
	    });
	});
    y2milestone( "ret %1", ret );
    return( ret );
    }

global define boolean PerformLosetup( map& loop, boolean format )
    ``{
    boolean crypt_ok = false;
    string pwd = loop["passwd"]:"";
    string device = loop["partitionName"]:"";
    string mdir = Storage::SaveDumpPath("tmp_mp" );
    y2milestone( "PerformLosetup mdir:%1", mdir );
    if( (integer)SCR::Read(.target.size, mdir ) >= 0 )
	{
	SCR::Execute(.target.bash, "rm -f " + mdir );
	}
    SCR::Execute(.target.mkdir, mdir );
    crypt_ok = Storage::SetCryptPwd( device, pwd ) &&
               Storage::SetCrypt( device, true, false ) &&
	       Storage::Mount( device, mdir );
    if( crypt_ok )
	{
	any vinfo = LibStorage::VolumeInfo::new("LibStorage::VolumeInfo");
	integer ret = LibStorage::StorageInterface::getVolume( sint, device,
	                                                       vinfo );
	if( ret!=0 )
	    {
	    y2error( "PerformLosetup device:%1 not found (ret:%2)", device, ret );
	    crypt_ok = false;
	    }
	else
	    {
	    map curr = $[];
	    curr = volumeMap( vinfo, curr );
	    loop["loop_dev"] = curr["loop"]:"";
	    y2milestone( "PerformLosetup loop:%1", loop["loop_dev"]:"" );
	    }
	SCR::Execute(.target.bash, "umount " + mdir );
	}
    y2milestone( "PerformLosetup ret %1", crypt_ok );
    return( crypt_ok );
    }

global define symbol DetectFs( string device )
    ``{
    symbol ret = `unknown;
    y2milestone( "DetectFs:%1", device );
    any vinfo = LibStorage::VolumeInfo::new("LibStorage::VolumeInfo");
    integer r = LibStorage::StorageInterface::getVolume( sint, device, vinfo );
    if( r!=0 )
	{
	y2error( "DetectFs device:%1 not found (ret:%2)", device, r );
	}
    else
	{
	map curr = $[];
	curr = volumeMap( vinfo, curr );
	ret = curr["detected_fs"]:`unknown;
	}
    y2milestone( "DetectFs ret %1", ret );
    return( ret );
    }

global define boolean DiskmapNeeded()
    ``{
    boolean ret = false;
    map<string,map> real_disks = filter( string k, map e, GetTargetMap(), ``(IsRealDisk( e )) );
    list<string> disks = (list<string>) maplist( string k, map e, real_disks, ``(k));
    y2milestone( "disks %1", disks );
    boolean scsi_disk = false;
    boolean ide_disk = false;
    foreach( string k, disks,
	``{
	if( search( k, "/dev/sd" )==0 )
	    {
	    scsi_disk = true;
	    }
	else if( search( k, "/dev/hd" )==0 )
	    {
	    ide_disk = true;
	    }
	else
	    {
	    ret = true;
	    }
	});
    ret = ret || (scsi_disk && ide_disk);
    if( !ret && ide_disk )
	{
	string abc = "abcdefghijklmnopqrstuvwxyz";
	integer idx = 0;
	foreach( string k, disks,
	    ``{
	    y2milestone( "dev %1 abc %2", substring(k, 7, 1),
	                 substring(abc, idx, 1));
	    if( substring(k, 7, 1) != substring(abc, idx, 1) )
		{
		ret = true;
		}
	    idx = idx+1;
	    });
	}
    y2milestone( "ret %1 disks %2 ide %3 scsi %4", ret, size(disks), ide_disk,
                 scsi_disk );
    return( ret );
    };

global define boolean UseLilo()
    ``{
    boolean ret = false;
    y2milestone( "ret %1", ret );
    return( ret );
    }

global define list<string> GetDirPatterns( string dir, list patterns )
    ``{
    list<string> ret = [];
    string cmd = sformat( "cd %1 && (ls %2 2>/dev/null)", dir,
                          mergestring( (list<string>)patterns, " "));
    map out = (map) SCR::Execute( .target.bash_output, cmd );
    ret = splitstring( out["stdout"]:"", "\n" );
    ret = filter( string e, ret, ``(size(e)>0) );
    ret = maplist( string e, ret, ``(dir+"/"+e));
    y2milestone( "dir %1 pat %2", dir, patterns );
    y2milestone( "ret %1", ret );
    return( ret );
    }

global define map GetBootPartition( string disk )
    ``{
    map ret = $[];
    map tg = GetTargetMap();
    ret = filter( map p, tg[disk,"partitions"]:[], ``(p["boot"]:false))[0]:$[];
    y2milestone( "disk:%1 ret:%2", disk, ret );
    return( ret );
    }

global define void UpdateFstabSubfs()
    ``{
    y2milestone( "UpdateFstabSubfs removing fstab entries for cdrom and floppy" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    list<integer> rem_lines = [];
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	if( search( l["fields",1]:"", "/media/floppy" )==0 )
	    {
       AsciiFile::ChangeLineField( fstab, line, 2, "auto" );
       AsciiFile::ChangeLineField( fstab, line, 3, FileSystems::GetFstabDefaultMntops("floppy") );

//	    rem_lines = add( rem_lines, line );
	    }
	else if( search( l["fields",1]:"", "/media/cdrom" )==0 ||
		 search( l["fields",1]:"", "/media/dvd" )==0 ||
		 search( l["fields",1]:"", "/media/cdrecorder" )==0 ||
		 search( l["fields",1]:"", "/media/dvdrecorder" )==0 ||
		 search( l["fields",1]:"", "/cdrom" )==0 ||
		 search( l["fields",1]:"", "/dvd" )==0 ||
		 search( l["fields",1]:"", "/cdrecorder" )==0 ||
		 search( l["fields",1]:"", "/dvdrecorder" )==0 )
	    {
	    rem_lines = add( rem_lines, line );
	    }
	line = line+1;
	}
    y2milestone( "UpdateFstabSubfs %1", rem_lines );
    if( size(rem_lines)>0 )
	{
	AsciiFile::RemoveLines( fstab, rem_lines );
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    }

global define void UpdateFstabSysfs()
    ``{
    y2milestone( "UpdateFstabSysfs called" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    boolean have_sysfs = false;
    while( !have_sysfs && line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	have_sysfs = l["fields",1]:"" == "/sys";
	line = line+1;
	}
    if( !have_sysfs )
	{
	map entry = FileSystems::GetFstabDefaultMap( "sys" );
	list fstlist = [ entry["spec"]:"", entry["mount"]:"",
			 entry["vfstype"]:"", entry["mntops"]:"",
			 sformat("%1",entry["freq"]:0),
		         sformat("%1",entry["passno"]:0) ];
	y2milestone( "UpdateFstabSysfs entry %1", entry );
	y2milestone( "UpdateFstabSysfs fstlist %1", fstlist );
	AsciiFile::AppendLine( fstab, fstlist );
	AsciiFile::RewriteFile( fstab, tabpath );
	}
    }

global string HdToIseries( string input )
    ``{
    string ret = input;
    string regex = "/dev/hd[a-z][0-9]*";
    if( regexpmatch( input, regex ))
	{
	ret = "/dev/iseries/vd" + substring( ret, 7 );
	}
    y2milestone( "HdToIseries input:%1 ret:%2", input, ret );
    return( ret );
    }

global string SLES9PersistentDevNames( string input )
    ``{
    string ret = input;
    string regex1 = "/dev/disk/by-id/.*";
    string regex2 = "/dev/disk/by-path/.*";
    string prefix = "scsi-";
    string tmpdev = "";

    if( regexpmatch( input, ".*-part[0-9]*$" ))
        {
	return input;
	}

    if( regexpmatch( input, ".*/by-id/(scsi|ccw|usb|ata)-.*$" ))
	{
	return input;
	}

    if( regexpmatch( input, regex1 ))
	{
	if (regexpmatch ( input, ".*/by-id/0X.{4}p?[0-9]?$" ) )
	    {
	    prefix = "ccw-";
	    }
	tmpdev = "/dev/disk/by-id/" + prefix + 
	         substring( input, findlastof(input, "/")+1 );
	y2milestone( "by id tmp %1", tmpdev );
	ret = tmpdev;
	}
    else if( regexpmatch( input, regex2 ))
	{
	tmpdev = input;
	y2milestone( "by path tmp %1", tmpdev );
	}

    if( size(tmpdev)>0  )
	{
	if( regexpmatch( tmpdev, ".*p[0-9]*$" ) )
	    {
	    ret = regexpsub( tmpdev, "(.*)p([0-9]*)$", "\\1-part\\2" );
	    }
	else
	    {
	    ret = regexpsub( tmpdev, "(.*[[:alpha:][:punct:]])([0-9]*)$", "\\1-part\\2" );
	    }
	}
    y2milestone( "SLES9PersistentDevNames input:%1 ret:%2", input, ret );
    return( ret );
    }

global string HdDiskMap( string input, map diskmap )
    ``{
    string ret = input;
    map d = GetDiskPartition( input );
    if( haskey( diskmap, d["disk"]:"" ))
	{
	ret = GetDeviceName( diskmap[d["disk"]:""]:"", d["nr"]:(any)0 );
	}
    y2milestone( "HdDiskMap input:%1 ret:%2", input, ret );
    return( ret );
    }

global define void UpdateFstabIseriesVd()
    ``{
    y2milestone( "UpdateFstabIseriesVd updating hdx to iseries/vdx" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    string n = "";
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	n = HdToIseries( l["fields",0]:"" );
	if( n != l["fields",0]:"" )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 0, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    tabpath = PathToDestdir( "/etc/cryptotab" );
    map crtab = Partitions::GetCrypto( tabpath );
    line = 0;
    while( line<=AsciiFile::NumLines( crtab ) )
	{
	map l = AsciiFile::GetLine( crtab, line );
	n = HdToIseries( l["fields",1]:"" );
	if( n != l["fields",1]:"" )
	    {
	    AsciiFile::ChangeLineField( crtab, line, 1, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( crtab, tabpath );
    }

global define void UpdateCdromLinks( map diskmap )
    ``{
    y2milestone( "UpdateCdromLinks map %1", diskmap );
    foreach( string link, StorageDevices::TypeNames,
	``{
	string dev = "/dev/" + link;
	string cont = (string)SCR::Read( .target.symlink, dev );
	if( cont!=nil && search( cont, "/dev/") != 0 )
	    cont = "/dev/" + cont;
	y2milestone( "UpdateCdromLinks dev %1 cont %2", dev, cont );
	if( cont!=nil && haskey( diskmap, cont ) && size(diskmap[cont]:"")>0 )
	    {
	    y2milestone( "Change symlink %1 from %2 -> %3", dev, cont,
	                 diskmap[cont]:"" );
	    SCR::Execute( .target.remove, dev );
	    SCR::Execute( .target.symlink, substring(diskmap[cont]:"",5), dev );
	    }
	});
    }

global define void UpdateFstabPersistentNames()
    ``{
    y2milestone( "UpdateFstabPersistentDevNames updating to SLES10 names" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    string n = "";
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	n = SLES9PersistentDevNames( l["fields",0]:"" );
	if( n != l["fields",0]:"" )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 0, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    }

global define void UpdateFstabDiskmap( map diskmap )
    ``{
    y2milestone( "UpdateFstabdiskmap map %1", diskmap );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    string n = "";
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	n = HdDiskMap( l["fields",0]:"", diskmap );
	if( n != l["fields",0]:"" )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 0, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    tabpath = PathToDestdir( "/etc/cryptotab" );
    map crtab = Partitions::GetCrypto( tabpath );
    line = 0;
    while( line<=AsciiFile::NumLines( crtab ) )
	{
	map l = AsciiFile::GetLine( crtab, line );
	n = HdDiskMap( l["fields",1]:"", diskmap );
	if( n != l["fields",1]:"" )
	    {
	    AsciiFile::ChangeLineField( crtab, line, 1, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( crtab, tabpath );
    }

global define void UpdateCryptoType()
    ``{
    y2milestone( "UpdateCryptoType" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    integer pos = 0;
    string searchstr = "encryption=twofish256";
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	pos = search( l["fields",3]:"", searchstr );
	if( pos != nil )
	    {
	    string new = substring( l["fields",3]:"", 0, pos );
	    new = new + "encryption=twofishSL92";
	    new = new + substring( l["fields",3]:"", pos+size(searchstr) );
	    y2milestone( "new options line in %1 is %2", l, new );
	    AsciiFile::ChangeLineField( fstab, line, 3, new );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    tabpath = PathToDestdir( "/etc/cryptotab" );
    map crtab = Partitions::GetCrypto( tabpath );
    line = 0;
    while( line<=AsciiFile::NumLines( crtab ) )
	{
	map l = AsciiFile::GetLine( crtab, line );
	if( l["fields",4]:"" == "twofish256" )
	    {
	    y2milestone( "set twofishSL92 in line %1", l );
	    AsciiFile::ChangeLineField( crtab, line, 4, "twofishSL92" );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( crtab, tabpath );
    }

global define void UpdateFstabUsbdevfs()
    ``{
    y2milestone( "UpdateFstabUsbdevfs updating usbdevfs to usbfs" );
    boolean changed = false;
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	if( l["fields",2]:"" == "usbdevfs" )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 2, "usbfs" );
	    AsciiFile::ChangeLineField( fstab, line, 0, "usbfs" );
	    changed = true;
	    }
	line = line+1;
	}
    if( changed )
	{
	y2milestone( "UpdateFstabUsbdevfs changed" );
	AsciiFile::RewriteFile( fstab, tabpath );
	}
    }


global define map BuildDiskmap( map oldv )
    ``{
    map d = (map)SCR::Read( .target.stat,
                            Installation::destdir + "/var/lib/hardware" );
    if( d["isdir"]:false && (oldv != DiskMapVersion || size(oldv)==0) )
	{
	DiskMap = $[];
	string cmd = "";
	cmd = "LIBHD_HDDB_DIR=" + Installation::destdir + "/var/lib/hardware " +
	      "hwinfo --map";
	y2milestone( "BuildDiskmap cmd %1", cmd );
	map bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "BuildDiskmap bo %1", bo );
	if( bo["exit"]:1==0 && size(bo["stdout"]:"")>0 )
	    {
	    list<string> lines = splitstring( bo["stdout"]:"", "\n" );
	    foreach( string line, lines,
		``{
		list<string> disks = filter( string d,
		                             splitstring( line, " \t" ),
					     ``(size(d)>0));
		if( size(disks)>1 )
		    {
		    integer index = 1;
		    while( index<size(disks) )
			{
			DiskMap[disks[index]:""] = disks[0]:"";
			index = index+1;
			}
		    }
		});
	    }
	if( bo["exit"]:1==0 )
	    DiskMapVersion = oldv;
	else
	    DiskMapVersion = $[];
	y2milestone( "BuildDiskmap bo %1", bo );
	y2milestone( "BuildDiskmap DiskMap %1", DiskMap );
	y2milestone( "BuildDiskmap DiskMapVersion %1", DiskMapVersion );
	}
    return( DiskMap );
    }

global define void Update( map oldv, map newv )
    ``{
    y2milestone( "Update old:%1 new:%2", oldv, newv );

    // Enterprise products do not have minor release number
    // map enterprise releases to corresponding code bases of SL
    map sles_major_to_minor = $[ 8 : 2, 9 : 1, 10 : 1 ];
    if( haskey( oldv, "major" ) && !haskey( oldv, "minor" ) )
	{
	oldv["minor"] = sles_major_to_minor[oldv["major"]:0]:0;
	y2milestone( "Update old:%1", oldv );
	}
    if( haskey( newv, "major" ) && !haskey( newv, "minor" ) )
	{
	newv["minor"] = sles_major_to_minor[newv["major"]:0]:0;
	y2milestone( "Update new:%1", newv );
	}
    if( !haskey( oldv, "major" ) || !haskey( newv, "major" ) )
	y2error( "Missing key major or minor" );

    if( oldv["major"]:0<=9 )
	{
	UpdateFstabSysfs();
	}
    if( oldv["major"]:0<9 )
	{
	UpdateFstabUsbdevfs();
	}
    if( oldv["major"]:0==9 )
        {
	UpdateFstabPersistentNames();
	}

    map dm = BuildDiskmap( oldv );
    if( size(dm)>0 )
	{
	UpdateFstabDiskmap( dm );
	}
    if( oldv["major"]:0<9 || (oldv["major"]:0==9 && oldv["minor"]:0<=2))
	{
	Storage::UpdateCryptoType();
	}
    if( oldv["major"]:0<10 || (oldv["major"]:0==10 && oldv["minor"]:0==0) )
	{
	string of = "/etc/udev/rules.d/20-cdrom.rules";
	y2milestone( "removing obsolete %1", of );
	SCR::Execute( .target.remove, of );
	of = "/etc/udev/rules.d/55-cdrom.rules";
	y2milestone( "removing obsolete %1", of );
	SCR::Execute( .target.remove, of );
	StorageDevices::MakeCDLinks();
	}
    if( oldv["major"]:0<10 || (oldv["major"]:0==10 && oldv["minor"]:0==0))
	UpdateFstabSubfs();
    if( oldv["major"]:0<9 || (oldv["major"]:0==9 && oldv["minor"]:0==0))
	{
	if( Arch::board_iseries () )
	    {
	    UpdateFstabIseriesVd();
	    }
	string cmd = "cd / && /sbin/insserv -r /etc/init.d/boot.evms";
	y2milestone( "Update cmd %1", cmd );
	map bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "Update bo %1", bo );
	}
    }

global define list<string> GetTranslatedDevices( map oldv, map newv,
						 list<string> names )
    {
    y2milestone( "GetTranslatedDevices old:%1 new:%2", oldv, newv );
    y2milestone( "GetTranslatedDevices names %1", names );
    list<string> ret = names;
    map dm = BuildDiskmap( oldv );
    if( size(dm)>0 )
	{
	ret = maplist( string n, ret, ``(HdDiskMap( n, dm )));
	}
    if( (oldv["major"]:0<9 || (oldv["major"]:0==9 && oldv["minor"]:0==0)) &&
        Arch::board_iseries () )
	{
	ret = maplist( string n, ret, ``(HdToIseries( n )));
	}
    if( oldv["major"]:0==9 )
	{
	ret = maplist( string n, ret, ``(SLES9PersistentDevNames( n )));
	}
    y2milestone( "GetTranslatedDevices ret %1", ret );
    return( ret );
    }

global define list GetUsedLvmGroups( map<string,map> tg )
    ``{
    list groups = [];
    foreach( string disk, map data, tg,
	``{
	if( data["type"]:`CT_UNKNOWN==`CT_LVM &&
	    size( filter( map p, data["partitions"]:[],
	                  ``(size(p["mount"]:"")>0 ) )) > 0 )
	    {
	    y2milestone( "GetUsedLvmGroups %1",
	                 filter( map p, data["partitions"]:[],
				 ``(size(p["mount"]:"")>0 ) ) );
	    groups = add( groups, substring( disk, 5 ) );
	    }
	});
    y2milestone( "GetUsedLvmGroups ret %1", groups );
    return( groups );
    };

/**
 * Get used real disks
 * @param tg Target map
 * @return disks List of disks
 */
global define list<string> GetUsedRealDisksNew( map<string,map> tg, 
                                                boolean ignore_boot )
    ``{
    list<string> disks = [];
    list lvmgr = GetUsedLvmGroups( tg );
    list mdlist = [];
    foreach( map p, tg["/dev/md","partitions"]:[],
	``{
	if( size(p["mount"]:"")>0  ||
	    contains( lvmgr, p["used_by"]:"" ) )
	    {
	    mdlist = add( mdlist, p["device"]:"" );
	    }
	});
    foreach( string disk, map data, tg,
	``{
	if( IsRealDisk( data ) &&
	    size( filter( map p, data["partitions"]:[],
	                  ``( (size(p["mount"]:"")>0 &&
			       (!ignore_boot ||
			        p["mount"]:""!=Partitions::BootMount())) ||
			      contains( mdlist, p["used_by"]:"" )  ||
			      contains( lvmgr, p["used_by"]:"" ) ) )) > 0 )
	    {
	    disks = add( disks, disk );
	    }
	});
    y2milestone( "GetUsedRealDisksNew ignore_boot %1 ret %2", 
                 ignore_boot, disks );
    return( disks );
    };

global define list<string> GetUsedRealDisks( map<string,map> tg )
    {
    return( GetUsedRealDisksNew( tg, false ));
    };

global define list<string> GetEvmsRealDisk( map<string,map> tg, map p )
    ``{
    list<string> rdisk = [];
    string name = "";
    string namel = "";
    if( size(p["device"]:"")>10 )
	name = substring( p["device"]:"", 10 );
    if( search( name, "lvm/" ) == 0 || search( name, "lvm2/" ) == 0)
	{
	name = substring( name, 0, findlastof( name, "/" ));
	}
    namel = name;
    integer pos = search( namel, "/" );
    if( pos != nil )
	{
	namel = substring( namel, pos+1 );
	}
    y2milestone( "GetEvmsRealDisk name is %1 namel is %2", name, namel );
    foreach( string disk, map data, tg,
	``{
	if( size(name)>0 &&
	    (IsRealDisk( data ) || disk=="/dev/md") &&
	    ((size( filter( map p, data["partitions"]:[],
	                  ``(p["used_by_type"]:`UB_NONE==`UB_EVMS && 
			     p["used_by"]:""==name)))>0) ||
	     (size( filter( map p, data["partitions"]:[],
	                  ``(p["used_by_type"]:`UB_NONE==`UB_LVM && 
			     p["used_by"]:""==namel)))>0) ))
	    {
	    list<string> dl = [ disk ];
	    if( disk=="/dev/md" )
		{
		list<map> tl = [];
		tl = filter( map p, data["partitions"]:[],
		             ``((p["used_by_type"]:`UB_NONE==`UB_EVMS &&
				 p["used_by"]:""==name)||
				(p["used_by_type"]:`UB_NONE==`UB_LVM &&
				 p["used_by"]:""==namel)));
		dl = maplist( map p, tl, ``(p["device"]:""));
		dl = (list<string>)sort( dl );
		dl = (list<string>)toset( dl );
		y2milestone( "GetEvmsRealDisk dl %1", dl );
		}
	    rdisk = (list<string>)union( rdisk, dl );
	    }
	});
    if( size(rdisk)==0 && !p["evms_native"]:false )
	{
	map d = GetDiskPartitionTg( EvmsDevDisk( p["device"]:"" ), tg );
	if( haskey( tg, d["disk"]:"" ))
	    {
	    rdisk = [ d["disk"]:"" ];
	    }
	}
    y2milestone( "GetEvmsRealDisk %1 is %2", p["device"]:"", rdisk );
    return( rdisk );
    }

global define list<string> GetUsedEvmsDisks( map<string,map> tg )
    ``{
    list<string> disks = [];
    list mdlist = [];
    foreach( string disk, map data, tg,
	``{
	if( search( disk, "/dev/evms" )==0 )
	    {
	    foreach( map p, data["partitions"]:[],
		``{
		if( size(p["mount"]:"")>0 )
		    {
		    list<string> dl = GetEvmsRealDisk( tg, p );
		    foreach( string d, dl,
			``{
			y2milestone( "GetUsedEvmsDisks d %1", d );
			if( search( d, "/dev/md" ) == 0 )
			    {
			    list<string> ndl = [];
			    foreach( string dd, map pp, tg,
				``{
				map pu = find( map p, pp["partitions"]:[], 
				               ``(p["used_by"]:""==substring(d,5)) );
				y2milestone( "GetUsedEvmsDisks disk:%1 used:%2", dd, pu );
				if( pu!=nil && size(pu)>0 )
				    {
				    ndl = add( ndl, dd );
				    }
				});
			    disks = (list<string>)union( disks, ndl );
			    }
			else
			    {
			    disks = (list<string>)union( disks, [d] );
			    }
			});
		    }
		});
	    }
	});
    disks = sort( disks );
    y2milestone( "GetUsedEvmsDisks ret %1", disks );
    return( disks );
    };

global define boolean CheckEvmsNonEvms()
    ``{
    boolean ret = true;
    if( DoCheckEvmsNonEvms )
	{
	map<string,map> tg = GetTargetMap();
	list<string> evms = GetUsedEvmsDisks( tg );
	list<string> nonevms = GetUsedRealDisksNew( tg, true );
	evms = filter( string d, evms, ``(contains( nonevms, d )));
	y2milestone( "CheckEvmsNonEvms intersec %1", evms );
	ret = size(evms)==0;
	}
    y2milestone( "CheckEvmsNonEvms ret %1", ret );
    return( ret );
    };

global define boolean CheckEvmsLvm()
    ``{
    boolean ret = true;
    if( DoCheckEvmsLvm )
	{
	map<string,map> tg = GetTargetMap();
	list evms = GetUsedEvmsDisks( tg );
	list lvms = GetUsedLvmGroups( tg );
	ret = size(evms)==0 || size(lvms)==0;
	}
    y2milestone( "CheckEvmsLvm ret %1", ret );
    return( ret );
    };

global list<map> GetPrepBoot( map<string,map> tg )
    {
    list<map> ret = [];
    list cl = [ 0x06, 0x41 ];
    foreach( string s, map e, tg,
	``{
	if( IsRealDisk( e ) && Partitions::PrepBoot() )
	    ret = (list<map>)merge( ret, filter( map p, e["partitions"]:[],
	                              ``( size(p["mount"]:"")==0 &&
				          contains( cl, p["fsid"]:0 ) &&
					  !p["delete"]:false )));
	});
    y2milestone( "GetPrepBoot ret:%1", ret );
    return( ret );
    }

global define void FinishInstall()
    ``{
    map<string,map> tg = GetTargetMap();
    HandleModulesOnBoot( tg );
    list evms = GetUsedEvmsDisks( tg );
    y2milestone( "FinishInstall evms %1", evms );
    list evmsmp = [];
    foreach( string k, map d, tg,
	``{
	if( search( k, "/dev/evms" )==0 )
	    {
	    evmsmp = merge( evmsmp, filter( map p, d["partitions"]:[],
					    ``( size(p["mount"]:"")>0 &&
						!p["delete"]:false )));
	    }
	});
    y2milestone( "FinishInstall evmsmp %1", evmsmp );
    if( size(evms)>0 || size(evmsmp)>0 )
	{
	string cmd = "cd / && /sbin/insserv /etc/init.d/boot.evms";
	y2milestone( "FinishInstall cmd %1", cmd );
	map bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "FinishInstall bo %1", bo );
	}
    list<string> nonevms = GetUsedRealDisks( tg );
    nonevms = filter( string d, nonevms, ``(!contains( evms, d )));
    nonevms = maplist( string d, nonevms, ``(substring(d,5)));
    y2milestone( "FinishInstall nonevms %1", nonevms );
    nonevms = (list<string>)merge( nonevms, maplist( map p, GetPrepBoot(tg),
				   ``(substring(p["device"]:"",5))));
    y2milestone( "FinishInstall nonevms %1", nonevms );
    if( size(nonevms)>0 && SCR::Read( .target.size, "/etc/evms.conf" )>=0 )
	{
	map evmsconf = $[];
	AsciiFile::ReadFile( evmsconf, "/etc/evms.conf" );
	boolean found = false;
	integer i = 1;
	string regex1 = "^[ \t]*activate[ \t]*\\{";
	string regex2 = "^[ \t]*exclude[ \t]*=";
	string regex3 = "^[ \t]*\\}";
	while( i<=AsciiFile::NumLines(evmsconf) && !found )
	    {
	    found = regexpmatch( evmsconf["l",i,"line"]:"", regex1 );
	    i = i+1;
	    }
	found = false;
	boolean found2 = false;
	while( i<=AsciiFile::NumLines(evmsconf) && !found && !found2)
	    {
	    found = regexpmatch( evmsconf["l",i,"line"]:"", regex2 );
	    found2 = regexpmatch( evmsconf["l",i,"line"]:"", regex3 );
	    if( found )
		{
		string co = evmsconf["l",i,"line"]:"";
		integer pos = search( co, "[" );
		if( pos!=nil )
		    co = substring( co, pos+1 );
		pos = search( co, "]" );
		if( pos!=nil )
		    co = substring( co, 0, pos );
		y2milestone( "FinishInstall co = \"%1\"", co );
		string li = "\texclude = [ " + co + mergestring( nonevms, " " ) +
		            " ]";
		y2milestone( "FinishInstall li = %1", li );
		evmsconf["l",i,"line"] = li;
		evmsconf["l",i,"buildline"] = false;
		AsciiFile::RewriteFile( evmsconf, "/etc/evms.conf" );
		}
	    i = i+1;
	    }
	}
    y2milestone( "FinishInstall" );
    }

global define map GetEntryForMountpoint( string mp )
    ``{
    list<map> all_partitions = [];
    foreach( string dev, map disk, GetTargetMap(),
	``{
	all_partitions = (list<map>)union( all_partitions,
	                                   disk["partitions"]:[] );
	});
    map partition = find( map part, all_partitions, ``(part["mount"]:""==mp) );
    if( partition==nil || partition["mount"]:"" != mp )
        {
	partition = $[];
	}
    return partition;
    }

global define list GetRootInitrdModules()
    ``{
    map partition = GetEntryForMountpoint( "/" );
    y2milestone("GetRootInitrdModules root partition %1", partition );

    map<string,map> tg = GetTargetMap();
    map disk = $[];
    foreach( string k, map d, tg, 
	``{
	if( size(disk)==0 && 
	    find( map p, d["partitions"]:[], 
	          ``(!p["delete"]:false &&
		     p["device"]:""==partition["device"]:""))!=nil )
	    disk = d;
	});
    y2milestone( "GetRootInitrdModules disk %1", 
                 haskey(disk,"partitions")?remove(disk,"partitions"):disk );

    list initrdmodules =
	FileSystems::GetNeededModules( partition["used_fs"]:`ext2 );

    if( partition["type"]:`unknown == `sw_raid )
	{
	string t = partition["raid_type"]:"";
	if (!contains (initrdmodules, t))
	    {
	    initrdmodules = add (initrdmodules, t);
	    }
	}
    if( partition["type"]:`unknown == `lvm )
	{
	string vgname = substring( partition["device"]:"", 5 );
	vgname = substring( vgname, 0, findfirstof( vgname, "/" ));
	list<string> mod =
	    (list<string>) maplist(map k, filter(map e, tg["/dev/md","partitions"]:[],
						 ``(e["used_by"]:""==vgname) ),
				   ``(k["raid_type"]:""));
	y2milestone( "GetRootInitrdModules mod %1", mod );
	foreach(string e, mod,
	    ``{
	    if( size(e)>0 && !contains( initrdmodules, e ) )
		{
		initrdmodules = add( initrdmodules, e );
		}
	    });
	if( !contains( initrdmodules, "dm_mod" ) )
	    {
	    initrdmodules = add( initrdmodules, "dm_mod" );
	    }
	}
    if( partition["type"]:`unknown == `evms )
	{
	string evmsco = partition["device"]:"";
	evmsco = substring( evmsco, 0, findlastof( evmsco, "/" ));
	y2milestone( "GetRootInitrdModules evmsco %1", evmsco );
	y2milestone( "GetRootInitrdModules evms %1", tg[evmsco]:$[] );
	list<string> md = filter( string s, tg[evmsco,"devices"]:[], ``(search(s,"/dev/md")==0));
	y2milestone( "GetRootInitrdModules mddev %1", md );
	list<string> mod =
	    (list<string>) maplist(map k, filter(map e, tg["/dev/md","partitions"]:[],
						 ``(contains(md,e["device"]:""))),
				   ``(k["raid_type"]:""));
	y2milestone( "GetRootInitrdModules mod %1", mod );
	foreach(string e, mod,
	    ``{
	    if( size(e)>0 && !contains( initrdmodules, e ) )
		{
		initrdmodules = add( initrdmodules, e );
		}
	    });
	if( !contains( initrdmodules, "dm_mod" ) )
	    {
	    initrdmodules = add( initrdmodules, "dm_mod" );
	    }
	}
    if( disk["driver"]:"" == "usb-storage" )
	{
	list<map> uc = (list<map>)SCR::Read(.probe.usbctrl);
	list<string> dl = maplist( map e, uc, ``(e["driver"]:""));
	y2milestone( "GetRootInitrdModules dl %1", dl );
	dl = (list<string>) toset(dl);
	y2milestone( "GetRootInitrdModules dl %1", dl );
	string first = "^ehci[_-]hcd$";
	list f = filter( string s, dl, ``(regexpmatch(s,first)));
	y2milestone( "GetRootInitrdModules first %1", f );
	if( size(f)>0 )
	    {
	    dl = (list<string>)merge( f, filter( string s, dl, 
	                                         ``(!regexpmatch(s,first))));
	    y2milestone( "GetRootInitrdModules dl %1", dl );
	    }
	initrdmodules = merge( initrdmodules, dl );
	initrdmodules = add( initrdmodules, "usb_storage" );
	}
    SCR::UnmountAgent (.proc.modules);
    map lmod = (map) SCR::Read(.proc.modules);
    y2milestone( "GetRootInitrdModules lmod:%1", lmod );
    if( size(lmod["edd"]:$[])>0 )
	initrdmodules = add( initrdmodules, "edd" );
    y2milestone( "GetRootInitrdModules ret %1", initrdmodules );
    return initrdmodules;
    };

/**
 * CheckForLvmRootFs
 *---------------------------------------------------------------------
 * check if the root filesystem is a lvm logical volume
 *
 **/
global define boolean CheckForLvmRootFs()
    ``{
    map part = GetEntryForMountpoint( "/" );
    y2milestone( "CheckForLvmRootFs root=%1", part );
    boolean ret = part["type"]:`primary==`lvm;
    y2milestone( "CheckForLvmRootFs ret=%1", ret );
    return ret;
    };

  /**
   * CheckForEvmsRootFs
   *---------------------------------------------------------------------
   * check if the root filesystem is a evms volume
   *
   **/
global define boolean CheckForEvmsRootFs()
    ``{
    map part = GetEntryForMountpoint( "/" );
    y2milestone( "CheckForEvmsRootFs root=%1", part );
    boolean ret = part["type"]:`primary==`evms;
    y2milestone( "CheckForEvmsRootFs ret=%1", ret );
    return ret;
    };



  /*---------------------------------------------------------------------
   * checkForMdRootFs
   *---------------------------------------------------------------------
   * check if the root filesystem is a md device
   *---------------------------------------------------------------------
   */
global define boolean CheckForMdRootFs()
    ``{
    map part = GetEntryForMountpoint( "/" );
    boolean ret = part["type"]:`primary==`sw_raid;
    y2milestone( "CheckForMdRootFs root=%1", part );
    y2milestone( "CheckForMdRootFs ret=%1", ret );
    return ret;
    };

global define void AdaptResize( string maindev, list region, integer schange )
    ``{
    map<string,map> tg = GetTargetMap();
    list<map> partitions = tg[maindev,"partitions"]:[];
    integer cylinder = region[0]:0 + region[1]:0;
    boolean found = false;
    integer index = -1;
    integer e_idx = -1;
    list<integer> idx_list = [];
    map part = (map) find(map p, partitions,
                          ``(p["region",0]:0 == cylinder && p["create"]:false));
    y2milestone( "AdaptResize %1 reg %2 change %3", maindev, region, schange );
    if( part != nil )
	{
	found = false;
	index = 0;
	foreach(map p, partitions,
	    ``{
	    if( p["region",0]:0 == cylinder && p["create"]:false )
		{
		found = true;
		}
	    else if( !found )
		{
		index = index + 1;
		}
	    });
	if( partitions[index,"type"]:`primary == `extended )
	    {
	    e_idx = index;
	    found = false;
	    index = 0;
	    foreach(map p, partitions,
		``{
		if( p["region",0]:0 == cylinder && p["create"]:false &&
		    p["type"]:`primary != `extended )
		    {
		    found = true;
		    part = p;
		    }
		else if( !found )
		    {
		    index = index + 1;
		    }
		});
	    }
	cylinder = part["region",0]:0 + part["region",1]:0;
	y2milestone( "AdaptResize part:%1", part );
	y2milestone( "AdaptResize index:%1 e_idx:%2 cylinder:%3", index, e_idx,
	             cylinder );
	map pnew = (map) find( map p, partitions,
	                       ``( p["region",0]:0 == cylinder &&
				   p["create"]:false ));
	y2milestone( "AdaptResize pnew:%1", pnew );
	while( pnew != nil &&
	       (part["mount"]:"" == Partitions::BootMount() ||
	        part["fsid"]:0==Partitions::fsid_swap ||
		part["region",1]:0 < (schange<0?(-1*schange):schange)) )
	    {
	    y2milestone( "AdaptResize pnew:%1", pnew );
	    part = pnew;
	    idx_list = add( idx_list, index );
	    y2milestone( "AdaptResize index:%1 idx_list:%2", index, idx_list );
	    found = false;
	    index = 0;
	    foreach(map p, partitions, ``{
	        y2milestone( "found:%1 index:%2 p=%3", found, index, p );
		if( p["nr"]:0 == pnew["nr"]:0 )
		    {
		    found = true;
		    }
		else if( !found )
		    {
		    index = index + 1;
		    }
		});
	    cylinder = part["region",0]:0 + part["region",1]:0;
	    pnew = (map) find( map p, partitions,
	                       ``( p["region",0]:0 == cylinder &&
				   p["create"]:false ));
	    }
	y2milestone( "AdaptResize idx:%1 list:%2", index, idx_list );

	foreach(integer num, idx_list, ``{
	    partitions[num,"region",0] = partitions[num,"region",0]:0 - schange;
	    UpdatePartition( partitions[num,"device"]:"", partitions[num,"region",0]:0,
			     partitions[num,"region",1]:1 );
	    });
	partitions[index,"region",0] = partitions[index,"region",0]:0 - schange;
	partitions[index,"region",1] = partitions[index,"region",1]:0 + schange;
	if( partitions[index,"region",1]:0 <= 0 )
	    {
	    partitions[index,"region",1] = 1;
	    }
	y2milestone( "AdaptResize increase p:%1", partitions[index]:$[] );
	UpdatePartition( partitions[index,"device"]:"", partitions[index,"region",0]:0,
	                 partitions[index,"region",1]:1 );
	if( e_idx>=0 )
	    {
	    partitions[e_idx,"region",0] = partitions[e_idx,"region",0]:0 - schange;
	    partitions[e_idx,"region",1] = partitions[e_idx,"region",1]:0 + schange;
	    if( partitions[e_idx,"region",1]:0 <= 0 )
		{
		partitions[e_idx,"region",1] = 1;
		}
	    UpdatePartition( partitions[e_idx,"device"]:"", partitions[e_idx,"region",0]:0,
			     partitions[e_idx,"region",1]:1 );
	    }
	}
    else
	{
	y2error( "AdaptResize this should not happen %1", partitions );
	}
    y2milestone( "AdaptResize partitions:%1", partitions );
    y2milestone( "AdaptResize maindev:%1 region:%2 change:%3", maindev,
                 region, schange );
    }


global define integer NumLoopDevices()
    {
    map bo = (map)SCR::Execute (.target.bash_output, "losetup -a" );
    list<string> sl = splitstring( bo["stdout"]:"", "\n" );
    sl = filter( string s, sl, ``(search( s, "/dev/loop" )==0 ));
    sl = maplist( string s, sl, ``(substring( s, 0, search( s, ":" ))));
    sl = maplist( string s, sl, ``(substring( s, 9 )));
    list<integer> il = sort( maplist( string s, sl, ``(tointeger(s))));
    integer ret = il[size(sl)-1]:-1 + 1;
    y2milestone( "NumLoopDevices ret:%1", ret );
    return( ret );
    }


//-----------------------------------------------------
// convert partitions to fstab entries
// return map (might be empty)
global define map onepartition2fstab (map part, integer& other_nr)
    ``{
    y2milestone( "onepartition2fstab part=%1", part );
    if (part["delete"]:false ||
	part["type"]:`unknown == `extended ||
	(contains( [ `lvm, `sw_raid, `evms ], part["type"]:`unknown ) &&
	 size(part["mount"]:"")==0) ||
	(part["enc_type"]:`none!=`none && !part["noauto"]:false) ||
	part["used_by_type"]:`UB_NONE != `UB_NONE ||
	(contains( [ Partitions::fsid_prep_chrp_boot, Partitions::fsid_lvm,
	             Partitions::fsid_raid ], part["fsid"]:0 ) &&
	 size(part["mount"]:"")==0))
	{
	return $[];
	}

    string spec = part["device"]:"";
    if( part["mountby"]:`device == `label && size(part["label"]:"")>0 )
	{
	spec = sformat("LABEL=%1", part["label"]:"" );
	}
    else if( part["mountby"]:`device == `uuid && size(part["uuid"]:"")>0 )
	{
	spec = sformat("UUID=%1", part["uuid"]:"" );
	}
    y2debug( "onepartition2fstab spec=%1", spec );
    string  mount_point = part["mount"]:"";
    integer fsid = part["fsid"]:0;

    symbol  used_fs = part["used_fs"]:`ext2;
    boolean format  = part["format"]:false;

    string  vfstype = "unknown";	// keep "unknown", used again below
    integer freq    = 0;
    integer passno  = 0;
    string  mntops  = part["fstopt"]:"";

    if( mount_point == "swap" )
	{
	vfstype = "swap";
	if( size(mntops) == 0 )
	    {
	    mntops = FileSystems::GetFstabDefaultMntops( "swap" );
	    }
	passno = 0;
	}
    else if( fsid==Partitions::fsid_native || fsid==Partitions::fsid_lvm ||
             (part["type"]:`unknown == `evms &&
	      part["detected_fs"]:`none!=`unknown) )
	{
	vfstype = FileSystems::GetMountString( used_fs,
	                                       (format ? "ext2" : "auto"));

	freq = 1;
	if( mount_point == "/" )
	    {
	    passno = 1;
	    }
	else if( mount_point != "" )
	    {
	    passno = 2;
	    }
	else if( Stage::initial () && !Arch::s390 () )
	    {
	    mount_point = "/data" + other_nr;
	    // Don't mount and fsck this filesystem during boot, its
	    // state is unknown.
	    mntops = "noauto,user";
	    vfstype = "auto";
	    freq = 0;
	    passno = 0;
	    other_nr = other_nr + 1;
	    y2milestone( "TT add MountPoint %1", mount_point );
	    }
	}
    else if( (Arch::i386()||Arch::ia64()||Arch::x86_64()) &&
             size(mount_point)>0 &&
             (used_fs==`vfat || used_fs==`ntfs) &&
             (contains(union(union(Partitions::fsid_dostypes,
				   Partitions::fsid_ntfstypes),
			     Partitions::fsid_wintypes), fsid ) ||
	      fsid==Partitions::fsid_gpt_boot))
	{
	freq = 0;
	passno = 0;
	string lower_point = tolower( mount_point );
	if( lower_point != "" && mount_point != lower_point)
	    {
	    if( Installation::scr_destdir != "/" )
		{
		lower_point = Installation::scr_destdir + lower_point;
		}
	    y2milestone( "symlink %1 -> %2",
	                 substring(mount_point,(findlastof(mount_point,"/")+1)),
			 lower_point );
	    SCR::Execute(.target.symlink,
	                 substring(mount_point,(findlastof(mount_point,"/")+1)),
	                 lower_point);
	    }
	vfstype = FileSystems::GetMountString( used_fs, "auto" );
	}
    else if( (Arch::sparc () || Arch::alpha ()) &&
	     contains (Partitions::fsid_skipped, fsid))
	{
	return $[];		// skip "whole disk" partition
	}
    else
	{
	return $[];	        // unknown type
	}
    if( part["detected_fs"]:`reiserfs == `unknown ||
        part["noauto"]:false )
	{
	passno = 0;
	}

    map ret = $[ "spec":spec,
                 "mount":mount_point,
		 "vfstype":vfstype,
                 "mntops":mntops,
		 "freq":freq,
		 "device":part["device"]:"",
		 "passno":passno ];

    if( size(ret["mntops"]:"")==0 )
	{
	ret["mntops"] = "defaults";
	}

    y2milestone( "onepartition2fstab ret=%1", ret );
    return( ret );
    };

global integer KmgtStrToByte( string input )
    ``{
    integer number = 0;
    integer pos = findfirstnotof( input, " +" );

    if( pos != nil && pos>0 )
	{
	input = substring( input, pos );
	}

    if( size(filterchars(input, "0123456789kKmMgGtTbBoO .")) != size(input))
       {
       return(0);
       }

    input = filterchars(input, "0123456789kKmMgGtTbBoO.");

    if( findfirstnotof( input, "0123456789.") != nil  )
        {
	// check whether the last char is in "kKmM" or "bB"
	string last_char = substring( input, size(input)-1, 1);

	if( last_char == "b" || last_char == "B" ||
	    last_char == "o" || last_char == "O" )
	    {
	    input = substring( input, 0, size(input)-1);
	    // check whether the last char is in "kKmM"
	    last_char = substring( input, size(input)-1, 1);
	    }

        string number_str = substring(input, 0, size(input)-1);

	if( findfirstnotof( number_str, "0123456789.") == nil )
	    {
	    if( last_char == "k" || last_char == "K" )
	        {
		number = tointeger(tofloat( number_str ) * 1024.0) ;
		}
	    else if ( last_char == "m" || last_char == "M" )
		{
		number = tointeger(tofloat( number_str ) * 1024.0 * 1024.0);
	        }
	    else if ( last_char == "g" || last_char == "G" )
		{
		number = tointeger(tofloat( number_str ) * 
				   1024.0 * 1024.0 * 1024.0);
		}
	    else if ( last_char == "t" || last_char == "T" )
	        {
		number = tointeger(tofloat( number_str ) * 
				   1024.0 * 1024.0 * 1024.0 * 1024.0);
		}
	    else
		{
		number = 0;
	        }
	    }
        else
	    {
	    number = 0;
	    }
        }
    else
        {
        number = tointeger( input );
        }
    return( number );
    };

global boolean InstallOES()
    {
    boolean ret = false;
    y2milestone( "InstallOES ret:%1", ret );
    return( ret );
    }

global boolean ProposalHome()
    {
    return( proposal_home );
    }

global void SetProposalHome(boolean val)
    {
    proposal_home = val;
    y2milestone( "SetProposalHome val:%1", proposal_home );
    }

global void SetProposalEvms(boolean val)
    {
    proposal_evms = val;
    if( val )
	proposal_lvm = false;
    y2milestone( "SetProposalEvms val:%1 lvm:%2 evms:%3", val,
                 proposal_lvm, proposal_evms );
    }

global void SetProposalLvm(boolean val)
    {
    proposal_lvm = val;
    if( val )
	proposal_evms = false;
    y2milestone( "SetProposalLvm val:%1 lvm:%2 evms:%3", val,
                 proposal_lvm, proposal_evms );
    }

global boolean ProposalEvms()
    {
    return( proposal_evms );
    }

global boolean ProposalLvm()
    {
    return( proposal_lvm );
    }

global void SetProposalDefault()
    {
    SetProposalHome( cfg_xml["home"]:false );
    if( cfg_xml["prop_evms"]:false )
	{
	SetProposalEvms(true);
	}
    else if( cfg_xml["prop_lvm"]:false )
	{
	SetProposalLvm(true);
	}
    else
	{
	SetProposalLvm(false);
	SetProposalEvms(false);
	}
    y2milestone( "SetProposalDefault lvm:%1 evms:%2 home:%3", 
                 proposal_lvm, proposal_evms, proposal_home );
    }

global map GetControlCfg()
    {
    if( size(cfg_xml)==0 )
	{
	boolean bt = ProductFeatures::GetBooleanFeature( "partitioning",
							 "try_separate_home" );
	cfg_xml["home"] = bt?true:false;
	cfg_xml["root_percent"] = 
	    tointeger(ProductFeatures::GetStringFeature( "partitioning",
							 "root_space_percent"));
	if( cfg_xml["root_percent"]:0 == nil || cfg_xml["root_percent"]:0 <= 0 )
	    cfg_xml["root_percent"] = 40;
	string tmp = ProductFeatures::GetStringFeature( "partitioning",
							"limit_try_home");
	cfg_xml["home_limit"] = KmgtStrToByte(tmp) / (1024*1024);
	if( cfg_xml["home_limit"]:0 <= 0 )
	    cfg_xml["home_limit"] = 5*1024;
	tmp = ProductFeatures::GetStringFeature( "partitioning",
						 "root_base_size");
	cfg_xml["root_base"] = KmgtStrToByte(tmp) / (1024*1024);
	if( cfg_xml["root_base"]:0 <= 0 )
	    cfg_xml["root_base"] = 3*1024;
	tmp = ProductFeatures::GetStringFeature( "partitioning",
						 "root_max_size");
	cfg_xml["root_max"] = KmgtStrToByte(tmp) / (1024*1024);
	if( cfg_xml["root_max"]:0 <= 0 )
	    cfg_xml["root_max"] = 10*1024;
	tmp = ProductFeatures::GetStringFeature( "partitioning",
						 "vm_desired_size");
	cfg_xml["vm_want"] = KmgtStrToByte(tmp) / (1024*1024);
	if( cfg_xml["vm_want"]:0 <= 0 )
	    cfg_xml["vm_want"] = 15*1024;
	tmp = ProductFeatures::GetStringFeature( "partitioning",
						 "vm_home_max_size");
	cfg_xml["home_max"] = KmgtStrToByte(tmp) / (1024*1024);
	if( cfg_xml["home_max"]:0 <= 0 )
	    cfg_xml["home_max"] = 25*1024;
	bt = ProductFeatures::GetBooleanFeature( "partitioning",
						 "proposal_evms" );
	cfg_xml["prop_evms"] = bt?true:false;
	bt = ProductFeatures::GetBooleanFeature( "partitioning",
						 "proposal_lvm" );
	cfg_xml["prop_lvm"] = bt?true:false;
	bt = ProductFeatures::GetBooleanFeature( "partitioning",
						 "evms_config" );
	cfg_xml["evms_config"] = bt?true:false;
	bt = ProductFeatures::GetBooleanFeature( "partitioning",
						 "enable_evms_proposal" );
	cfg_xml["enable_evms_proposal"] = bt?true:false;
	bt = ProductFeatures::GetBooleanFeature( "partitioning",
						 "evms_boot" );
	cfg_xml["evms_boot"] = bt?true:false;
	SetProposalDefault();
	y2milestone( "GetControlCfg cfg_xml %1", cfg_xml );
	}
    return( cfg_xml );
    }

global boolean BootEvms()
    {
    map cfg = GetControlCfg();
    boolean ret = cfg["evms_boot"]:false;
    y2milestone( "BootEvms ret %1", ret );
    return( ret );
    }

global string ProposalVM()
    {
    string ret = "";
    map xml = GetControlCfg();
    if( proposal_evms || proposal_lvm )
	{
	ret = "system";
	}
    y2milestone( "ProposalVM lvm:%1 evms:%2 ret:%3", 
                 proposal_lvm, proposal_evms, ret );
    return( ret );
    }


global void AddHwPackage( string name )
    {
    y2milestone( "AddHwPackage name %1 list:%2", name, hw_packages );
    if( find( string s, hw_packages, ``(s==name)) == nil )
	hw_packages = add( hw_packages, name );
    y2milestone( "AddHwPackage list:%1", hw_packages );
    }

global void SwitchUiAutomounter( boolean on )
    {
    y2milestone( "SwitchUiAutomounter on:%1", on );
    string cmd = "hal-set-property " +
		  "--udi /org/freedesktop/Hal/devices/computer " +
		  "--key storage.disable_volume_handling --bool ";
    cmd = cmd + (on?"false":"true");
    y2milestone( "SwitchUiAutomounter cmd %1", cmd );
    SCR::Execute( .target.bash, cmd );
    y2milestone( "SwitchUiAutomounter exit" );
    }

global void DumpObjectList()
    {
    if( sint == nil )
	InitLibstorage();
    LibStorage::StorageInterface::dumpObjectList(sint);
    }

global define list<string> NoProposeDisks()
    {
    if( no_propose_disks == nil )
	{
	no_propose_disks = [];
	if( Stage::initial() && SCR::Read( .target.size, "/etc/install.inf" )>0 )
	    {
	    string inst = (string) SCR::Read( .etc.install_inf.Partition );
	    y2milestone( "NoProposeDisks .etc.install_inf.Partition \"%1\"", 
	                 inst );
	    if( inst!=nil && size(inst)>0 )
		{
		if( search( inst, "/dev/" )!=0 )
		    inst = "/dev/" + inst;
		map d = GetDiskPartition( inst );
		y2milestone( "NoProposeDisks inst:%1 disk:%2", inst, d );
		if( size(d["disk"]:"")>0 )
		    no_propose_disks = add( no_propose_disks, d["disk"]:"" );
		}
	    inst = (string) SCR::Read( .etc.install_inf.Cdrom );
	    y2milestone( "NoProposeDisks .etc.install_inf.Cdrom \"%1\"", inst );
	    if( inst!=nil && size(inst)>0 )
		{
		if( search( inst, "/dev/" )!=0 )
		    inst = "/dev/" + inst;
		map d = GetDiskPartition( inst );
		y2milestone( "NoProposeDisks inst:%1 disk:%2", inst, d );
		if( size(d["disk"]:"")>0 )
		    no_propose_disks = add( no_propose_disks, d["disk"]:"" );
		}
	    }
	if( Stage::initial() )
	    {
	    map ret = (map)SCR::Execute( .target.bash_output, "echo $YAST2_STORAGE_NO_PROPOSE_DISKS" );
	    y2milestone( "NoProposeDisks ret \"%1\"", ret["stdout"]:"" );
	    list ls = filter( string e, splitstring( ret["stdout"]:"", " \t\n" ), ``(size(e)>0) );
	    no_propose_disks = (list<string>)merge( no_propose_disks, ls );
	    }
	y2milestone( "NoProposeDisks \"%1\"", no_propose_disks );
	}
    return( no_propose_disks );
    }


global void SetDefaultMountBy(symbol mby)
{
    integer val = fromSymbol( conv_mountby, mby );
    LibStorage::StorageInterface::setDefaultMountBy(sint, val);
}


global symbol GetDefaultMountBy()
{
    integer val = LibStorage::StorageInterface::getDefaultMountBy(sint);
    symbol ret = toSymbol(conv_mountby, val);
    return ret;
}


global symbol GetMountBy( string device )
    {
    integer val = 0;
    integer r = LibStorage::StorageInterface::getMountBy( sint, device, val );
    symbol ret = toSymbol( conv_mountby, val );
    return( ret );
    }

global boolean DeviceMatchFstab( string device, string fstab_spec )
    {
    boolean ret = false;
    map<string,map> tg = GetTargetMap();
    string ts = GetTranslatedDevices( $[], $[], [ fstab_spec ] )[0]:"";
    if( ts!=fstab_spec )
	y2milestone( "DeviceMatchFstab translate %1 --> %2", fstab_spec, ts );
    map p = GetPartition( tg, ts );
    ret = p["device"]:"" == device;
    y2milestone( "DeviceMatchFstab device:%1 fstab:%2 ret:%3", device, 
                 fstab_spec, ret );
    return( ret );
    }

global boolean Storage::IsPersistent( map p )
    {
    boolean ret = contains( [ `lvm, `sw_raid, `dm ], p["type"]:`unknown );
    if( !ret && contains( [ `evms, `primary, `logical, `extended ],
                          p["type"]:`unknown ))
	{
	map d = GetDisk( GetTargetMap(), p["device"]:"" );
	if( p["type"]:`unknown==`evms )
	    ret = d["is_container"]:false || p["evms_native"]:false;
	else 
	    ret = size(d["udev_id"]:[])>0;
	}
    y2milestone( "IsPersistent device:%1 ret:%2", p["device"]:"", ret );
    return( ret );
    }

}
