/**
 * Module:		inst_prepdisk.ycp
 *
 * Authors:		Mathias Kettner (kettner@suse.de) (initial)
 *			Stefan Schubert (schubi@suse.de)
 *			Klaus Kaempf (kkaempf@suse.de)
 *
 * Purpose:
 * Displays a progress bar showing progress of disk preparation.
 * The user has the opportunity to cancel the installation. The
 * disks are partitioned. Swap is created and used. File systems
 * are created for the new partitions. Mount points are created
 * and mounted for the targets / and /boot.
 *
 *
 * possible return values: `back, `abort `next
 */
{
  textdomain "storage";
  
  import "Mode";
  import "Stage";
  import "Storage";
  import "String";
  import "SlideShow";
  import "StorageClients";
  
  if (Mode::update ())
    return `auto;

  SCR::Write( .target.ycp, Storage::SaveDumpPath("targetMap_ps"), 
              Storage::GetTargetMap() );

  y2milestone( "BEGINNING of inst_prepdisk" );

  if( Mode::normal() )
  {
	// we need to open dialog and set up slideshow
	SlideShow::Setup(
  		[
    		$[
    			"name" : "disk",
    			"description": _("Preparing disks..."),
    			"value" : Mode::update() ? 0 : 120, // FIXME: 2 minutes
    			"units" : `sec,
    		],
		]

	);

	SlideShow::OpenDialog();
  }

  // They are usually more than twice the reported value
  // create, format, mount ...
  StorageClients::total_actions = size(Storage::GetCommitInfos()) * 2.5;
  y2milestone ("StorageClients::total_actions: %1", StorageClients::total_actions);

  SlideShow::MoveToStage( "disk" );

  y2milestone( "installation=%1", Stage::initial() );
  symbol ret_val = `next;

  integer ret = Storage::CommitChanges();
  y2milestone( "CommitChanges ret:%1", ret );
  if( ret!=0 )
      ret_val = `abort;

  if( Stage::initial() )
      {
      Storage::WriteFstab();

      /*
       * If a kernel without initrd is booted, then there is a small window
       * between mounting the root filesystem until /etc/init.d/boot
       * mounts /dev as tmpfs mount. A few device nodes have to be on-disk,
       * like /dev/console, /dev/null etc.
       * During install time, provide the same set of device nodes to the chroot
       * They are needed at the end for the bootloader installation.
       */
      string cmd = "mkdir -vp '" + String::Quote(Storage::PathToDestdir("/dev")) + "'; "
	+ "cp --preserve=all --recursive --remove-destination /lib/udev/devices/* '" + String::Quote(Storage::PathToDestdir("/dev")) + "'; "
	+ "mount -v --bind /dev '" + String::Quote(Storage::PathToDestdir("/dev")) + "'";
      y2milestone( "cmd %1", cmd );
      map m = (map) SCR::Execute(.target.bash_output, cmd );
      y2milestone( "ret %1", m );
      string destproc = Storage::PathToDestdir("/proc");
      SCR::Execute (.target.mount, ["proc", destproc], "-t proc");
      destproc = Storage::PathToDestdir("/sys");
      SCR::Execute (.target.mount, ["sysfs", destproc], "-t sysfs");

      // mounting /run for udev (bnc#717321)
      cmd = "mkdir -vp '" + String::Quote(Storage::PathToDestdir("/run")) + "'; " +
	  "mount -v --bind /run '" + String::Quote(Storage::PathToDestdir("/run")) + "'";
      y2milestone("cmd %1", cmd);
      m = (map) SCR::Execute(.target.bash_output, cmd);
      y2milestone("ret %1", m);
      }
  else
      {
      Storage::FinishInstall();
      }

  // close progress on running system
  if( Mode::normal() )
  	SlideShow::CloseDialog();

  SCR::Write( .target.ycp, Storage::SaveDumpPath("targetMap_pe"), 
	      Storage::GetTargetMap() );

  y2milestone("END of inst_prepdisk.ycp");

  return ret_val;
}
